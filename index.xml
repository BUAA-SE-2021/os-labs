<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pintos 实验规划 on OS Pintos Labs</title><link>https://buaa-se-2021.github.io/os-labs/</link><description>Recent content in Pintos 实验规划 on OS Pintos Labs</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://buaa-se-2021.github.io/os-labs/index.xml" rel="self" type="application/rss+xml"/><item><title>Problem Set 0</title><link>https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/ps0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/ps0/</guid><description>Problem Set 0 # 实验说明 # 单人完成，代码要求每人一份（只需提交两个 *.c文件）。除代码外，还需要提交文档。内容可为设计和需求说明、解决思路等，无文档模板，自由发挥。 对于每个人而言，请仅提交一个 PDF 文件（如果有多个文档，请合并成一个。推荐把所有内容写在一个 Markdown/LaTex 项目里）。由组长将每个人的代码文件和 PDF 文档收齐后，将每个人的提交内容放在各自的文件夹后打包为 Zip 包提交。 本次实验因为不涉及多人合作，故对 Git 的使用没有要求。此后的 Project 1 开始，会对小组使用 Git 的情况进行考察。 本实验需要利用操作系统的同步机制，实现问题中要求的逻辑功能。 实验代码可在官网中自行下载，无需 Pintos 环境即可直接运行。 实验内容 # Problem 1：自动化车站 乘客行为：到站台等车、车来则上车 火车行为：到站装载乘客，无人等待或车已满就开走 让乘客和火车的行为流畅运行，以实现车站的自动化管理 Problem 2：氢原子与氧原子结合，生成 H2O 2 个 H 和 1 个 O 生成水分子 如何保证 H2O 结构正常生成，不会遗漏或多加原子 Problem 1 # 需求 # CalTrain 程序想让你通过自动化列车和乘客管理来提高效率。每名乘客和每列火车都由一个线程控制。 要求编写同步函数，以确保列车的有序装载。避免出现多人上车座位不够的情况。</description></item><item><title>周例会报告模板</title><link>https://buaa-se-2021.github.io/os-labs/docs/resources/weekly-meeting-report/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buaa-se-2021.github.io/os-labs/docs/resources/weekly-meeting-report/</guid><description>周例会报告 # 会议基本信息 # 会议日期： 时间： 参会人员： 地点： 记录人： 会议主题： 规划议程 # 会议内容 # 简述会议实际进程，突出谁发现了什么问题，谁解决了什么问题，并是怎么解决的
下一阶段目标和打算 # 参会人员小结 # 空白模板 # # 周例会报告 ## 会议基本信息 - 会议日期： - 时间： - 参会人员： - 地点： - 记录人： - 会议主题： ## 规划议程 ## 会议内容 &amp;gt; 简述会议实际进程，突出谁发现了什么问题，谁解决了什么问题，并是怎么解决的 ## 下一阶段目标和打算 ## 参会人员小结 参考的填写模板 # # 周例会报告 ## 会议基本信息 - 会议日期：20210930 - 时间：15:00-18:00 - 参会人员：zzj、hhz、wyh、lrq - 地点：腾讯会议、新主楼 - 记录人：zyh - 会议主题：开始实验前任务布置 ## 规划议程 - 15:00-16:00 一起读题 - 16:00-17:00 讨论解决思路 - 17:00-18:00 看代码，debug ## 会议内容 zzj 带领我们看了一下代码的结构，根据助教的提示明确了实验内容要做什么。 wyh 发现在 `xx.</description></item><item><title>Pintos 环境搭建</title><link>https://buaa-se-2021.github.io/os-labs/docs/resources/install-pintos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buaa-se-2021.github.io/os-labs/docs/resources/install-pintos/</guid><description>Pintos 环境搭建 # Author: Muyung, YinghaoZhu
另外，感谢李宇轩（huahuaxiaomuzhu）同学提供在 Docker 中配置 Pintos 的方法。详见 pintos-docker。张开颜同学的配置方法也可以参考 buaa_pintos。
依赖安装 # 我所使用的实验环境为 VMware Workstation 16 Player (免费) 上运行的 Ubuntu 16.04 64 位版本（32 位版本不可以）。
Download VMware Workstation 16 Player Download Ubuntu 16.04 选择 ubuntu-16.04.7-desktop-amd64.iso 安装 GNU binutils # 安装成功后，终端运行 i386-elf-objdump -i，应输出：
BFD header file version (GNU Binutils) 2.21.1 elf32-i386 (header little endian, data little endian) i386.</description></item><item><title>Project 1</title><link>https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/p1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/p1/</guid><description>Project 1: Threads # 需要提交代码和文档。代码即为包含了 pintos/src 的源代码，文档则是在本网站 Resources 区“实验文档模板”和“Project 1 DesignDoc 模板”的整合版本，云平台上可下载。请将其整合导出为一个 PDF 文件，命名为 p1-组长学号-组长姓名.pdf ，并与代码文件打包为 Zip，提交至云平台。
提交的目录结构为：
p1-组长学号-组长姓名 ├── pintos ├── src ...... ├── p1-组长学号-组长姓名.pdf 本次实验的 DDL 是 2021 年 11 月 11 日晚 23 时。
实验背景知识 # Pintos 简介 # Pintos 是一个小型的操作系统，其运行在 x86 硬件模拟器 bochs 之上。其已经实现了一个功能较少的操作系统，我们要做的事情就是给这个操作系统添加功能。
Pintos 结构图如上所示。和市面上常见的操作系统类似，Pintos 将整个体系分为了用户态和内核态，用户态的程序通过系统调用获得内核的服务。其操作系统内核主要分为进程管理、内存管理、文件系统、设备驱动程序等四个部分。本次实验所涉及到的主要是进程管理的部分，同学们需要根据需求实现特定的进程调度方案。
Pintos 目录结构 # 本节将主要给大家介绍 Pintos 中比较重要的几个文件夹。
在整个 Pintos 实验课中，我们要修改的代码都在 src 目录下。Project 1 的实验中，我们所要修改的文件主要集中在 src/threads 和 src/devices 这两个目录中，由于具体实现方式不同，有的同学也会有可能修改到少量其他目录中的文件。</description></item><item><title>Project 2</title><link>https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/p2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/p2/</guid><description>Project 2: User Programs # 实验的意义探究 # 我们知道，pintos 实验旨在通过补充代码，实现一个小型的操作系统。那么这个操作系统，到底是什么级别的系统呢？
这个需要从 intel 公司的 80x86 系列处理器说起。通过之前计组和系统编程已经学习到的知识，大家应该都知道 8086 处理器是一个 16 位处理器，系统总线 20 根，可寻址最大内存空间达 1MB，范围是 00000H-FFFFFH，但其内部的寄存器和 ALU 都只有 16 位，所以在寻址时，需要将段地址乘以 16，再加上偏移地址，以此来实现 20 位的寻址。这都是后话，最主要的是，在 8086 时代，用户可以直接寻址到内存空间的任何位置，这就有可能导致用户错误地修改某些地址值，导致系统崩溃。
由于技术的进步以及人们对多用户操作同一台电脑的需求，在 80386 时代，终于将系统的工作方式给分离了，80386 具有实模式、保护模式和 v68 模式这三种工作模式。其中，实模式其实算是 8086 体系的延续，在该模式下的寻址方式和 8086 无异，这个模式也是为了兼容 16 位体系下的程序。而用户一般所处的状态就是保护模式，在这个模式下可以使用 386 系统的 32 根主线，寻址模式发生根本性的变化，最主要的是引入了特权级的概念，由于我们知道在 8086 时代，随意的内存修改可能导致系统崩溃，而想要避免这种崩溃，就需要把系统内核给保护起来，为此，386 有个 4 个特权级 r0-3，我们的系统内核在最高级别 r0 中，特权级所处的内存空间分置，允许高特权级访问低特权级内存空间，而不允许反向地访问。那么这样一来，确实避免了随意对内存空间的修改，可又引出了一些新的问题，比如系统对外设端口的调用，是通过中断的方式进行的；比如创建新的进程等，这些函数都被内核给把持着，当一个用户想要手动开启这些功能的时候，就遇到了无法访问的问题，这个时候，就需要让低特权级向高特权级发起一个建议，这个建议我们把他叫做系统调用，使用系统调用，就可以让用户在低特权级下使用高特权级的功能。
而这，就是我们第二次实验所要完成的事情。
实验思路讲解 # 大部分思路可以参照官方文档中的 3.2 章节。
在本次实验中，我们需要完成 10 余个系统调用的实现。首先系统调用本质上会落实到函数中，函数需要有参数，而通过计组的学习，我们已经知道，这些参数被放在栈中，当 eip 执行到 call 指令时，会将当前栈顶地址压栈，再将栈底地址赋值给栈顶，而这个时候，参数就被存放在栈底之下。我们的 pintos 实际上也是类似的操作。</description></item><item><title>实验文档模板</title><link>https://buaa-se-2021.github.io/os-labs/docs/resources/doc-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buaa-se-2021.github.io/os-labs/docs/resources/doc-template/</guid><description>Project X 实验文档模板 # Project X (X = 1, 2, 3)
团队 # 基本信息 # 姓名 学号 Git 用户名 每位组员的主要工作内容 # Git 相关 # Pintos 的 Git 项目地址
参考资料 # 资料 1 资料 2 实验要求 # 需求分析 # 设计思路 # 可描述算法描述、数据结构等</description></item><item><title>Project 1 DesignDoc 模板</title><link>https://buaa-se-2021.github.io/os-labs/docs/resources/project01-design-doc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buaa-se-2021.github.io/os-labs/docs/resources/project01-design-doc/</guid><description>Project 1 Design Document # QUESTION 1: ALARM CLOCK # DATA STRUCTURES # A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.
ALGORITHMS # A2: Briefly describe what happens in a call to timer_sleep(), including the effects of the timer interrupt handler.</description></item><item><title>Project 2 DesignDoc 模板</title><link>https://buaa-se-2021.github.io/os-labs/docs/resources/project02-design-doc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://buaa-se-2021.github.io/os-labs/docs/resources/project02-design-doc/</guid><description>Project 2 Design Document # QUESTION 1: ARGUMENT PASSING # DATA STRUCTURES # A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.
ALGORITHMS # A2: Briefly describe how you implemented argument parsing. How do you arrange for the elements of argv[] to be in the right order?</description></item></channel></rss>