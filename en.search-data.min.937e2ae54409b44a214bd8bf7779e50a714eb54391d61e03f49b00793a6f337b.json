[{"id":0,"href":"/os-labs/docs/table-of-contents/ps0/","title":"Problem Set 0","section":"Table of Contents","content":"Problem Set 0 #  实验说明 #   单人完成，代码要求每人一份（只需提交两个 *.c文件）。除代码外，还需要提交文档。内容可为设计和需求说明、解决思路等，无文档模板，自由发挥。 对于每个人而言，请仅提交一个 PDF 文件（如果有多个文档，请合并成一个。推荐把所有内容写在一个 Markdown/LaTex 项目里）。由组长将每个人的代码文件和 PDF 文档收齐后，将每个人的提交内容放在各自的文件夹后打包为 Zip 包提交。 本次实验因为不涉及多人合作，故对 Git 的使用没有要求。此后的 Project 1 开始，会对小组使用 Git 的情况进行考察。 本实验需要利用操作系统的同步机制，实现问题中要求的逻辑功能。 实验代码可在官网中自行下载，无需 Pintos 环境即可直接运行。  实验内容 #   Problem 1：自动化车站  乘客行为：到站台等车、车来则上车 火车行为：到站装载乘客，无人等待或车已满就开走 让乘客和火车的行为流畅运行，以实现车站的自动化管理   Problem 2：氢原子与氧原子结合，生成 H2O  2 个 H 和 1 个 O 生成水分子 如何保证 H2O 结构正常生成，不会遗漏或多加原子    Problem 1 #  需求 #  CalTrain 程序想让你通过自动化列车和乘客管理来提高效率。每名乘客和每列火车都由一个线程控制。 要求编写同步函数，以确保列车的有序装载。避免出现多人上车座位不够的情况。\n步骤 #   定义 station 结构体  包含程序所用的信号量、锁、条件变量   编写以下处理函数：  初始化函数：station_init(struct station *station) 初始化结构体中的数据   列车行为：  火车到站打开车门：station_load_train(struct station *station, int count) 当且仅当列车已满或无乘客等待时，该函数返回   乘客行为：  到站等车，添加一名位于等待状态的乘客：station_wait_for_train(struct station *station) 乘客就坐，“通知”列车当前乘客已经就坐：station_on_board(struct station *station)   外层调用无需考虑，只需定义结构体和同步机制所需的函数  要求 #   允许多名乘客等车 只需改动 caltrain.c 不能造成忙等待 只能使用以下函数  lock_init (struct lock *lock) lock_acquire(struct lock *lock) lock_release(struct lock *lock) cond_init(struct condition *cond) cond_wait(struct condition *cond, struct lock *lock) cond_signal(struct condition *cond, struct lock *lock) cond_broadcast(struct condition *cond, struct lock *lock)    Problem 2 #  需求 #  大自然母亲聘请你帮助她解决形成水的化学反应，但是她似乎无法正确处理反应中的同步问题。 将两个 H 原子和一个 O 原子同时放在一起即可生成水分子， 每个原子由一个线程表示。\n步骤 #   定义 reaction 结构体 包含程序所用的信号量、锁、条件变量 编写以下处理函数：  初始化函数：reaction_init(struct reaction *r) 氢氧原子准备结合：void reaction_h(struct reaction *r)、void reaction_o(struct reaction *r) 每有一个 H 或 O 原子进入等待，调用该函数，结合成功后返回   在代码中包含结合水的函数：make_water()  无需实现，已经给出，需要在逻辑中加入    要求 #   允许多个原子等待反应 不能造成忙等待 只需改动 reation.c 只能使用以下函数  lock_init (struct lock *lock) lock_acquire(struct lock *lock) lock_release(struct lock *lock) cond_init(struct condition *cond) cond_wait(struct condition *cond, struct lock *lock) cond_signal(struct condition *cond, struct lock *lock) cond_broadcast(struct condition *cond, struct lock *lock)    测试方法 #   在代码根目录下命令行运行 make run 重新编译记得 make clean  正常运行时命令行输出：\n...Train departed station with 17 new passenger(s) (expected 17) Looks good! ./reaction 0 Created 0 H and 200 O atoms (0.0% H), expecting 0 H2O molecules Looks good! "},{"id":1,"href":"/os-labs/docs/resources/weekly-meeting-report/","title":"周例会报告模板","section":"Resources","content":"周例会报告 #  会议基本信息 #   会议日期： 时间： 参会人员： 地点： 记录人： 会议主题：  规划议程 #  会议内容 #   简述会议实际进程，突出谁发现了什么问题，谁解决了什么问题，并是怎么解决的\n 下一阶段目标和打算 #  参会人员小结 #  空白模板 #  # 周例会报告 ## 会议基本信息  - 会议日期： - 时间： - 参会人员： - 地点： - 记录人： - 会议主题： ## 规划议程  ## 会议内容 \u0026gt; 简述会议实际进程，突出谁发现了什么问题，谁解决了什么问题，并是怎么解决的  ## 下一阶段目标和打算  ## 参会人员小结 参考的填写模板 #  # 周例会报告 ## 会议基本信息  - 会议日期：20210930 - 时间：15:00-18:00 - 参会人员：zzj、hhz、wyh、lrq - 地点：腾讯会议、新主楼 - 记录人：zyh - 会议主题：开始实验前任务布置 ## 规划议程  - 15:00-16:00 一起读题 - 16:00-17:00 讨论解决思路 - 17:00-18:00 看代码，debug ## 会议内容  zzj 带领我们看了一下代码的结构，根据助教的提示明确了实验内容要做什么。 wyh 发现在 `xx.h` 里，需要定义一个新的结构体，因为 `xxx.c` 里要用，我们要通过它来实现同步。 lrq 认为`void` 的使用还难，我们一起查了下网上博客，发现他的用法有 xxx。 会议的最后，hhz 给 zzj、wyh、lrq 倒了杯卡布奇诺，说“兄弟们，辛苦了”。 ## 下一阶段目标和打算  提前做完实验，下一周讨论一下 Project 2 怎么搞。 ## 各参会人员小结  ### zzj  今天我带领了组内成员读了题目，解决了重要 BUG，顺利 AK。 ### hhz  ... "},{"id":2,"href":"/os-labs/docs/resources/install-pintos/","title":"Pintos 环境搭建","section":"Resources","content":"Pintos 环境搭建 #   Author: Muyung, YinghaoZhu\n 另外，感谢李宇轩（huahuaxiaomuzhu）同学提供在 Docker 中配置 Pintos 的方法。详见 pintos-docker。张开颜同学的配置方法也可以参考 buaa_pintos。\n依赖安装 #  我所使用的实验环境为 VMware Workstation 16 Player (免费) 上运行的 Ubuntu 16.04 64 位版本（32 位版本不可以）。\n  Download VMware Workstation 16 Player  Download Ubuntu 16.04  选择 ubuntu-16.04.7-desktop-amd64.iso    安装 GNU binutils #  安装成功后，终端运行 i386-elf-objdump -i，应输出：\nBFD header file version (GNU Binutils) 2.21.1 elf32-i386 (header little endian, data little endian) i386... 如果未出现这一信息，则需要安装 binutils ：\n首先下载该依赖包：终端执行 wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2\n解压并安装：\ntar xjf binutils-2.21.1.tar.bz2 cd binutils-2.21.1 ./configure --prefix=/usr/local --target=i386-elf --disable-werror make sudo make install # 这一步权限必不可少 cd .. 安装 Bochs #  这里采用的 Bochs 版本是 2.6.7，而非 Pintos 推荐的 2.2.6，因为过旧版本的 bochs 已经无法通过新版本 gcc 的编译。\n这里先将可能用到的依赖都安装验证一遍：\nsudo apt-get update # 更新 apt 库 sudo apt-get -y install build-essential # -y 参数自动确认 (Y/n) sudo apt-get -y install xorg-dev sudo apt-get -y install bison sudo apt-get -y install libgtk2.0-dev sudo apt-get -y install libc6:i386 libgcc1:i386 libstdc++5:i386 libstdc++6:i386 sudo apt-get -y install libncurses5:i386 sudo apt-get -y install g++-multilib  下载 bochs02.6.7 链接\n点击\u0026quot;bochs-2.6.7.tar.gz\u0026quot;下载，解压并安装（其与 Pintos 都已上传至 BUAA-SE-2021 pintos 仓库的 materials 文件夹下，可一起压缩后拖到虚拟机里去再解压，直接拖文件夹会比较慢）：\ntar xzf bochs-2.6.7.tar.gz cd bochs-2.6.7 chmod +x ./configure # 赋可执行权限 ./configure --enable-gdb-stub make sudo make install # 这一步权限必不可少 Pintos 安装 #  解压该 Ubuntu 16 所对应版本的 Pintos\ntar xzf pintos.tar.gz 复制脚本 #  这一步需要把 pintos/src/utils 文件夹下的诸多脚本文件添加到环境变量 PATH 下，这里直接将它们复制至 /usr/bin 文件夹下。\ncd ~/pintos/src/utils # 进入 Pintos 所在的文件夹，此处为家目录 sudo cp backtrace /usr/bin sudo cp pintos /usr/bin sudo cp pintos-gdb /usr/bin sudo cp pintos-mkdisk /usr/bin sudo cp pintos-set-cmdline /usr/bin sudo cp Pintos.pm /usr/bin cd ../misc sudo cp gdb-macros /usr/bin 安装 pintos-gdb #  首先编辑 /usr/bin/pintos-gdb 文件，将其中的常量 GDBMACROS 改为放置 gdb-macros 副本的路径（即：/usr/bin/gdb-macros）\nsudo vi /usr/bin/pintos-gdb # Modify the 4th line: GDBMACROS=/usr/bin/gdb-macros 然后设置脚本的执行权限\ncd /usr/bin/ sudo chmod a+rx backtrace sudo chmod a+rx pintos* sudo chmod a+rx gdb-macros sudo chmod a+rx Pintos.pm test pintos-gdb # 如果未提示缺少 gdb-macros 则安装成功 编译 utils #  修改 Makefile 文件，将第 5 行的 LDFLAGS 修改为 LDLIBS\ncd ~/pintos/src/utils vi Makefile # Modify the 5th line: LDFLAGS -\u0026gt; LDLIBS make 命令编译，并将支持文件导入 /usr/bin\nmake sudo cp squish-pty /usr/bin sudo cp squish-unix /usr/bin sudo chmod a+rx /usr/bin/squish* 安装并运行 #  执行如下命令：\ncd ~/pintos/src/threads make cd build chmod +x ../../utils/pintos # 可能需要赋可执行权限 ../../utils/pintos -- run alarm-multiple 即可看到 Pintos 的运行界面，含以下输出：\nUse of literal control characters in variable names is deprecated at ../../utils/pintos line 911. Prototype mismatch: sub main::SIGVTALRM () vs none at ../../utils/pintos line 935. Constant subroutine SIGVTALRM redefined at ../../utils/pintos line 927. squish-pty bochs -q ======================================================================== Bochs x86 Emulator 2.6.7 Built from SVN snapshot on November 2, 2014 Compiled on Sep 28 2021 at 01:44:48 ======================================================================== 00000000000i[ ] reading configuration from bochsrc.txt 00000000000e[ ] bochsrc.txt:8: \u0026#39;user_shortcut\u0026#39; will be replaced by new \u0026#39;keyboard\u0026#39; option. 00000000000i[ ] installing x module as the Bochs GUI 00000000000i[ ] using log file bochsout.txt PiLo hda1 Loading........... Kernel command line: run alarm-multiple Pintos booting with 4,096 kB RAM... 383 pages available in kernel pool. 383 pages available in user pool. Calibrating timer... 204,600 loops/s. Boot complete. Executing \u0026#39;alarm-multiple\u0026#39;: (alarm-multiple) begin (alarm-multiple) Creating 5 threads to sleep 7 times each. (alarm-multiple) Thread 0 sleeps 10 ticks each time, (alarm-multiple) thread 1 sleeps 20 ticks each time, and so on. (alarm-multiple) If successful, product of iteration count and (alarm-multiple) sleep duration will appear in nondescending order. (alarm-multiple) thread 0: duration=10, iteration=1, product=10 (alarm-multiple) thread 0: duration=10, iteration=2, product=20 (alarm-multiple) thread 1: duration=20, iteration=1, product=20 (alarm-multiple) thread 2: duration=30, iteration=1, product=30 (alarm-multiple) thread 0: duration=10, iteration=3, product=30 (alarm-multiple) thread 0: duration=10, iteration=4, product=40 (alarm-multiple) thread 1: duration=20, iteration=2, product=40 (alarm-multiple) thread 3: duration=40, iteration=1, product=40 (alarm-multiple) thread 4: duration=50, iteration=1, product=50 (alarm-multiple) thread 0: duration=10, iteration=5, product=50 (alarm-multiple) thread 1: duration=20, iteration=3, product=60 (alarm-multiple) thread 2: duration=30, iteration=2, product=60 (alarm-multiple) thread 0: duration=10, iteration=6, product=60 (alarm-multiple) thread 0: duration=10, iteration=7, product=70 (alarm-multiple) thread 1: duration=20, iteration=4, product=80 (alarm-multiple) thread 3: duration=40, iteration=2, product=80 (alarm-multiple) thread 2: duration=30, iteration=3, product=90 (alarm-multiple) thread 4: duration=50, iteration=2, product=100 (alarm-multiple) thread 1: duration=20, iteration=5, product=100 (alarm-multiple) thread 1: duration=20, iteration=6, product=120 (alarm-multiple) thread 2: duration=30, iteration=4, product=120 (alarm-multiple) thread 3: duration=40, iteration=3, product=120 (alarm-multiple) thread 1: duration=20, iteration=7, product=140 (alarm-multiple) thread 4: duration=50, iteration=3, product=150 (alarm-multiple) thread 2: duration=30, iteration=5, product=150 (alarm-multiple) thread 3: duration=40, iteration=4, product=160 (alarm-multiple) thread 2: duration=30, iteration=6, product=180 (alarm-multiple) thread 3: duration=40, iteration=5, product=200 (alarm-multiple) thread 4: duration=50, iteration=4, product=200 (alarm-multiple) thread 2: duration=30, iteration=7, product=210 (alarm-multiple) thread 3: duration=40, iteration=6, product=240 (alarm-multiple) thread 4: duration=50, iteration=5, product=250 (alarm-multiple) thread 3: duration=40, iteration=7, product=280 (alarm-multiple) thread 4: duration=50, iteration=6, product=300 (alarm-multiple) thread 4: duration=50, iteration=7, product=350 (alarm-multiple) end Execution of \u0026#39;alarm-multiple\u0026#39; complete. "},{"id":3,"href":"/os-labs/docs/table-of-contents/p1/","title":"Project 1","section":"Table of Contents","content":"Project 1: Threads #  需要提交代码和文档。代码即为包含了 pintos/src 的源代码，文档则是在本网站 Resources 区“实验文档模板”和“Project 1 DesignDoc 模板”的整合版本，云平台上可下载。请将其整合导出为一个 PDF 文件，命名为 p1-组长学号-组长姓名.pdf ，并与代码文件打包为 Zip，提交至云平台。\n提交的目录结构为：\np1-组长学号-组长姓名 ├── pintos ├── src ...... ├── p1-组长学号-组长姓名.pdf 本次实验的 DDL 是 2021 年 11 月 11 日晚 23 时。\n实验背景知识 #  Pintos 简介 #  Pintos 是一个小型的操作系统，其运行在 x86 硬件模拟器 bochs 之上。其已经实现了一个功能较少的操作系统，我们要做的事情就是给这个操作系统添加功能。\n Pintos 结构图如上所示。和市面上常见的操作系统类似，Pintos 将整个体系分为了用户态和内核态，用户态的程序通过系统调用获得内核的服务。其操作系统内核主要分为进程管理、内存管理、文件系统、设备驱动程序等四个部分。本次实验所涉及到的主要是进程管理的部分，同学们需要根据需求实现特定的进程调度方案。\nPintos 目录结构 #  本节将主要给大家介绍 Pintos 中比较重要的几个文件夹。\n在整个 Pintos 实验课中，我们要修改的代码都在 src 目录下。Project 1 的实验中，我们所要修改的文件主要集中在 src/threads 和 src/devices 这两个目录中，由于具体实现方式不同，有的同学也会有可能修改到少量其他目录中的文件。\n. ├── devices # 包含一些与硬件交互的内容 ├── examples # 包含 Pintos 对一些常用 Shell 命令的实现 ├── filesys # 包含 Pintos 中对文件系统的实现 ├── lib # 包含 C 语言中的一些标准库 ├── LICENSE ├── Make.config ├── Makefile ├── Makefile.build ├── Makefile.kernel ├── Makefile.userprog ├── misc ├── tests # 包含各实验的测试文件 ├── threads # 包含 Pintos 对于内核线程的实现 ├── userprog # 包含 Pintos 对于用户线程的实现 ├── utils └── vm 10 directories, 6 files 实验运行方式 #  在实验正式开始前，请同学们修改文件 pintos/src/tests/Make.tests 中的第 55 行\nTESTCMD = pintos -v -k -T $(TIMEOUT) # 修改前 TESTCMD = pintos -k -T $(TIMEOUT) # 修改后 否则，在某些同学的电脑上可能测试无法正常进行。\n修改完毕后，在 Project 1 实验中，代码的运行方式为：\n 进入 src/threads 目录 使用 make clean 命令清除上次编译后的信息 使用 make check 命令对文件进行编译并运行，首次运行会得到如图所示的过点信息：  pass tests/threads/alarm-single pass tests/threads/alarm-multiple FAIL tests/threads/alarm-simultaneous FAIL tests/threads/alarm-priority pass tests/threads/alarm-zero pass tests/threads/alarm-negative FAIL tests/threads/priority-change FAIL tests/threads/priority-donate-one FAIL tests/threads/priority-donate-multiple FAIL tests/threads/priority-donate-multiple2 FAIL tests/threads/priority-donate-nest FAIL tests/threads/priority-donate-sema FAIL tests/threads/priority-donate-lower FAIL tests/threads/priority-fifo FAIL tests/threads/priority-preempt FAIL tests/threads/priority-sema FAIL tests/threads/priority-condvar FAIL tests/threads/priority-donate-chain FAIL tests/threads/mlfqs-load-1 FAIL tests/threads/mlfqs-load-60 FAIL tests/threads/mlfqs-load-avg FAIL tests/threads/mlfqs-recent-1 pass tests/threads/mlfqs-fair-2 pass tests/threads/mlfqs-fair-20 FAIL tests/threads/mlfqs-nice-2 FAIL tests/threads/mlfqs-nice-10 FAIL tests/threads/mlfqs-block 21 of 27 tests failed. 常用文件介绍 #   在 src/tests/threads 文件夹中，包含了实验一的所有测试文件。 make check 之后，src/threads 中会生成一个 build 文件，文件夹 src/threads/build/tests/threads 中包含了程序在每一个测试点的输出。  实验介绍 #  本次实验一共有三个小任务，本文档将依次对它们进行介绍。 实验一文档中有更加详细的介绍，同学们做实验过程中有任何疑问都可以自行查阅官方文档。\n任务一：唤醒时钟 #  这个是本次实验中最为简单的一个任务。在原始的代码实现中，timer_sleep() 函数的实现如下：\nvoid timer_sleep (int64_t ticks) { int64_t start = timer_ticks (); ASSERT (intr_get_level () == INTR_ON); while (timer_elapsed (start) \u0026lt; ticks) thread_yield (); } 由代码最后两行，在原本的代码实现中，timer_sleep() 函数实现的是一个“忙等待”，当线程在调用 timer_sleep() 函数之后，会睡眠 ticks 个单位时间。\n根据题意，我们所要做的事便是消除这种忙等待。根据这个要求，可以想到使用时钟中断。在 thread.h 文件中，可以看到，Pintos 线程一共有以下几个状态：\nenum thread_status { THREAD_RUNNING, /* 运行态。 */ THREAD_READY, /* 就绪态。 */ THREAD_BLOCKED, /* 阻塞态。 */ THREAD_DYING /* 销毁态。 */ }; 因此，线程睡眠时，我们可以将其设置为阻塞态。而睡眠时间结束之后，将其设置为就绪态即可。\n在第一个小实验中，涉及到的测试点一共有以下几个：\n   测试点名称 测试内容     alarm-single 测试单个线程能否在规定时间后被唤醒   alarm-multiple 测试多个线程能否在规定之间后被唤醒   alarm-simultaneous 创建多个线程，并且在同一个时间进入睡眠状态，每个线程的睡眠时长不同，测试唤醒顺序是否正确。   alarm-zero 测试睡眠时长为 0 的情况   alarm-negative 测试睡眠时长为负数的情况    注意点：\n需要考虑到睡眠时长为 0 或者负数的情况\n任务二：优先级调度 #  这是本次实验最难的任务，主要包含以下两大部分：实现优先级调度和实现优先级捐赠。\n实现优先级调度 #  优先级调度概念：\n在原始的代码实现中，线程的就绪队列基本采用的是先来先服务（FCFS）的调度方式，即先进入就绪队列的线程在调度时会先获得 CPU，这个实验的目的是将这种调度策略改成优先级调度。即当一个线程被添加到就绪列表中，并且该线程的优先级高于当前正在运行的线程时，当前线程应该立即将处理器交付给新线程。类似地，当有多个线程正在等待锁、信号量或条件变量时，优先级最高的等待线程应该首先被唤醒。\n在 Pintos 中，线程优先级范围为 0 到 63。 较低的数字对应较低的优先级，因此优先级 0 是最低优先级，优先级 63 是最高优先级。 线程创建时默认的优先级为 PRI_DEFAULT = 31。\n在这一部分涉及的代码测试点主要有：\n   测试点名称 测试内容     alarm-priority 创建不同优先级的线程，看他们唤醒之后的调度是否符合优先级顺序。   priority-change 降低线程的优先级，观察设置之后优先级比它高的线程是否被立刻调度。   priority-sema 测试信号量唤醒时，是否会唤醒信号量等待队列中优先级最高的线程。   priority-condvar 测试条件变量唤醒时，是否会唤醒条件变量等待队列中优先级最高的线程。    注意点：\n在实现优先级调度的时候，不仅仅需要考虑线程的就绪队列，还要考虑信号量和条件变量的等待队列。\n实现优先级捐赠 #  优先级捐赠概念：\n在本实验中，优先级捐赠主要是针对线程对于锁的获取的。例如：如果线程 H 拥有较高的优先级，线程 M 拥有中等的优先级，线程 L 拥有较低的优先级。此时若线程 H 正在等待 L 持有的锁, 且 M 一直在就绪队列之中，那么线程 H 将永远无法获得 CPU。因此，这个时候需要将 H 的优先级捐赠给 L。\nH M L | ^ | | └------------------ 申请锁 注意点：\n 一个锁只能被单个线程持有，而一个线程却可以持有多个锁。当线程持有多个锁时，需要将线程的优先级设置为其被捐赠的优先级中最大的。 会出现递归捐赠的问题。例如当前存在一个高优先级线程 H，一个中优先级线程 M，一个低优先级线程 L。如果 H 正在申请 M 持有的锁，M 正在申请 L 持有的锁，那么 M 和 L 的优先级都需要被设置为 H 的优先级。  等待锁 等待锁 H -\u0026gt; M -\u0026gt; L 以下是这部分内容所涉及的测试点：\n   测试点名称 测试内容     priority-donate-one 提出优先级捐赠概念，用一个线程给另一个线程捐赠优先级，利用打印优先级和标答做对比来判断是否通过。   priority-donate-multiple 用两个线程给一个线程捐赠优先级，观察优先级恢复的时候是否符合预期的答案。   priority-donate-multiple2 测试线程在释放锁的瞬间，是否会被高优先级线程抢占。   priority-donate-nest 创建三个线程 A、B、C，先让 B 给 A 捐赠优先级，再让 C 给 B 捐赠优先级，观察 A 的优先级是否有改变。   priority-donate-sema 锁 + 优先级捐赠 + 信号量混合，之后说明测试过程。   priority-donate-lower 在优先级捐赠生效的情况下降低线程的优先级，希望是线程的优先级没有被改变，并在释放锁之后恢复到刚刚设置的优先级。    任务三：高级调度 #  在优先级调度策略之中，高优先级的进程永远抢占着 CPU，而低优先级线程能获得的时间非常少。在本实验中，我们会实现更加复杂的调度器，该实验所实现的调度器会自动维护线程的优先级。同样的，在任何给定的时间，调度程序从最高优先级的非空队列中选择一个线程。本实验需要弄清楚以下几个概念：\n ready_threads：代表当前正在处于运行态和就绪态的线程的数量。 load_avg：代表对过去一秒钟内准备运行的线程的数量的估计，其初始值被设置为 0，每一秒（100 个 ticks），load_avg 会按照以下公式进行更新：load_avg = 59/60 * load_avg + 1/60 * ready_threads。 recent_cpu：每一个线程都拥有的变量，反应该线程获得 cpu 的多少。每一个 ticks，正在运行的线程的 recent_cpu 会增加 1。每一秒(100 个 ticks)，所有的线程的 recent_cpu 会按照以下公式进行更新：recent_cpu = (2 * load_avg) / (2 * load_avg + 1) * recent_cpu + nice。 nice：代表线程对其他线程的友好程度，取值范围为 0 到 20，nice 值为 0 不会影响该线程的优先级，nice 值越大，该线程对其他线程越友好，即该线程的优先级越低，线程创建时初始 nice 值为 0。 priority：线程的优先级，每四个 ticks，线程的优先级应当按照以下公式进行更新：priority = PRI_MAX - 1/4 * recent_cpu - 2 * nice。  注意点：\n 在 Pintos 中，存在一个 thread_mlfqs 的布尔量控制高级调度，当其值为 true 时，使用高级调度，当值为 false 时，使用优先级调度。高级调度和优先级调度存在少部分冲突，需要特殊判断。 如果前两个任务实现的时间复杂度过高，会影响该任务的测试。 使用公式计算的优先级可能超出 Pintos 设定的优先级范围(0-63) 在本实验之前请各位确保已经阅读 任务三详细文档，本实验中涉及到浮点运算的部分都需要使用该文档中所提及到的方法。  任务三的测试样例如下：\n   测试点名称 测试内容     mlfqs-load-1 加载 1 个线程（主线程），运行一段时间后睡眠，检查 load_avg 有没有算对。   mlfqs-load-60 加载 60 个线程，同上，检查 load_avg 有没有算对。   mlfqs-load-avg 加载 60 个线程，并有一次唤醒和睡眠的行为，检查 load_avg 有没有算对。   mlfqs-recent-1 加载 1 个线程（主线程），睡眠一段时间后唤醒，检查 recent_cpu 有没有算对。   mlfqs-fair-2 运行 2 个nice = 0的线程，检查他们间运行时间的差距。   mlfqs-fair-20 运行 20 个nice = 0 的线程，检查他们间运行时间的差距。   mlfqs-nice-2 运行 1 个nice = 0和 1 个nice = 5的线程，共运行 3000 时间，检查他们的运行时长。   mlfqs-nice-10 运行 10 个nice为 0 ~ 9 的线程，共运行 3000 时间，检查他们的运行时长。   mlfqs-block 检查在 mlfqs 模式下优先级捐赠会不会改变线程优先级等级，正常下不改变。    "},{"id":4,"href":"/os-labs/docs/resources/doc-template/","title":"实验文档模板","section":"Resources","content":"Project X 实验文档模板 #   Project X (X = 1, 2, 3)\n 团队 #  基本信息 #     姓名 学号 Git 用户名                          每位组员的主要工作内容 #  Git 相关 #   Pintos 的 Git 项目地址\n参考资料 #    资料 1  资料 2  实验要求 #  需求分析 #  设计思路 #   可描述算法描述、数据结构等\n 重难点讲解 #   可写踩坑记录、Debug 的解决方案等\n 用户手册 #  测试报告 #  各成员的心得体会 #  Student1 #  Student2 #  \u0026hellip;\n其他你认为有必要的内容 (Optional) #  空白 Markdown 模板 #  # Project X 实验文档 ## 团队  ### 基本信息  | 姓名 | 学号 | | ---- | ---- | | | | | | | | | | | | | ### 每位组员的主要工作内容  ### Git 相关  [Pintos 的 Git 项目地址]() ### 参考资料  1. []() 2. []() ## 实验要求  ## 需求分析  ## 设计思路  ## 重难点讲解  ## 用户手册  ## 测试报告  ## 各成员的心得体会  ### Student1  ### Student2  ### Student3  ### Student4  ## 其他你认为有必要的内容 (Optional) "},{"id":5,"href":"/os-labs/docs/resources/project01-design-doc/","title":"Project 1 DesignDoc 模板","section":"Resources","content":"Project 1 Design Document #  QUESTION 1: ALARM CLOCK #  DATA STRUCTURES #   A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n ALGORITHMS #   A2: Briefly describe what happens in a call to timer_sleep(), including the effects of the timer interrupt handler.\n  A3: What steps are taken to minimize the amount of time spent in the timer interrupt handler?\n SYNCHRONIZATION #   A4: How are race conditions avoided when multiple threads call timer_sleep() simultaneously?\n  A5: How are race conditions avoided when a timer interrupt occurs during a call to timer_sleep()?\n RATIONALE #   A6: Why did you choose this design? In what ways is it superior to another design you considered?\n QUESTION 2: PRIORITY SCHEDULING #  DATA STRUCTURES #   B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n  B2: Explain the data structure used to track priority donation. Use ASCII art to diagram a nested donation. (Alternately, paste an image.)\n ALGORITHMS #   B3: How do you ensure that the highest priority thread waiting for a lock, semaphore, or condition variable wakes up first?\n  B4: Describe the sequence of events when a call to lock_acquire() causes a priority donation. How is nested donation handled?\n  B5: Describe the sequence of events when lock_release() is called on a lock that a higher-priority thread is waiting for.\n SYNCHRONIZATION #   B6: Describe a potential race in thread_set_priority() and explain how your implementation avoids it. Can you use a lock to avoid this race?\n RATIONALE #   B7: Why did you choose this design? In what ways is it superior to another design you considered?\n QUESTION 3: ADVANCED SCHEDULER #  DATA STRUCTURES #   C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n ALGORITHMS #   C2: Suppose threads A, B, and C have nice values 0, 1, and 2. Each has a recent_cpu value of 0. Fill in the table below showing the scheduling decision and the priority and recent_cpu values for each thread after each given number of timer ticks:\n    timer ticks recent_cpu A recent_cpu B recent_cpu C priority A priority B priority C thread to run     0          4          8          12          16          20          24          24          32          36            C3: Did any ambiguities in the scheduler specification make values in the table uncertain? If so, what rule did you use to resolve them? Does this match the behavior of your scheduler?\n  C4: How is the way you divided the cost of scheduling between code inside and outside interrupt context likely to affect performance?\n RATIONALE #   C5: Briefly critique your design, pointing out advantages and disadvantages in your design choices. If you were to have extra time to work on this part of the project, how might you choose to refine or improve your design?\n 空白模板 #  # Project 1 Design Document ## QUESTION 1: ALARM CLOCK  ### DATA STRUCTURES \u0026gt; A1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less.  ### ALGORITHMS \u0026gt; A2: Briefly describe what happens in a call to timer_sleep(), including the effects of the timer interrupt handler. \u0026gt; A3: What steps are taken to minimize the amount of time spent in the timer interrupt handler?  ### SYNCHRONIZATION \u0026gt; A4: How are race conditions avoided when multiple threads call timer_sleep() simultaneously? \u0026gt; A5: How are race conditions avoided when a timer interrupt occurs during a call to timer_sleep()?  ### RATIONALE \u0026gt; A6: Why did you choose this design? In what ways is it superior to another design you considered?  ## QUESTION 2: PRIORITY SCHEDULING  ### DATA STRUCTURES \u0026gt; B1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less. \u0026gt; B2: Explain the data structure used to track priority donation. Use ASCII art to diagram a nested donation. (Alternately, paste an image.)  ### ALGORITHMS \u0026gt; B3: How do you ensure that the highest priority thread waiting for a lock, semaphore, or condition variable wakes up first? \u0026gt; B4: Describe the sequence of events when a call to lock_acquire() causes a priority donation. How is nested donation handled? \u0026gt; B5: Describe the sequence of events when lock_release() is called on a lock that a higher-priority thread is waiting for.  ### SYNCHRONIZATION \u0026gt; B6: Describe a potential race in thread_set_priority() and explain how your implementation avoids it. Can you use a lock to avoid this race?  ### RATIONALE \u0026gt; B7: Why did you choose this design? In what ways is it superior to another design you considered?  ## QUESTION 3: ADVANCED SCHEDULER  ### DATA STRUCTURES \u0026gt; C1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less.  ### ALGORITHMS \u0026gt; C2: Suppose threads A, B, and C have nice values 0, 1, and 2. Each has a recent_cpu value of 0. Fill in the table below showing the scheduling decision and the priority and recent_cpu values for each thread after each given number of timer ticks:  | timer ticks | `recent_cpu` A | `recent_cpu` B | `recent_cpu` C | `priority` A | `priority` B | `priority` C | thread to run | | ----------- | -------------- | -------------- | -------------- | ------------ | ------------ | ------------ | ------------- | | 0 | | | | | | | | | 4 | | | | | | | | | 8 | | | | | | | | | 12 | | | | | | | | | 16 | | | | | | | | | 20 | | | | | | | | | 24 | | | | | | | | | 24 | | | | | | | | | 32 | | | | | | | | | 36 | | | | | | | | \u0026gt; C3: Did any ambiguities in the scheduler specification make values in the table uncertain? If so, what rule did you use to resolve them? Does this match the behavior of your scheduler? \u0026gt; C4: How is the way you divided the cost of scheduling between code inside and outside interrupt context likely to affect performance?  ### RATIONALE \u0026gt; C5: Briefly critique your design, pointing out advantages and disadvantages in your design choices. If you were to have extra time to work on this part of the project, how might you choose to refine or improve your design? "},{"id":6,"href":"/os-labs/docs/table-of-contents/","title":"Table of Contents","section":"Docs","content":"你好，操作系统！ #  Hello, Pintos!\n目录 #  实验目录可见左侧边栏\n"},{"id":7,"href":"/os-labs/docs/resources/","title":"Resources","section":"Docs","content":"课程相关资源 #  此处存放了周例会的模板及每次实验需要提交的文档模板。\n"}]