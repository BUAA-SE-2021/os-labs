<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Project 2: User Programs #  实验的意义探究 #  我们知道，Pintos 实验旨在通过补充代码，实现一个小型的操作系统。那么这个操作系统，到底是什么级别的系统呢？
这个需要从 Intel 公司的 80x86 系列处理器说起。通过之前计组和系统编程已经学习到的知识，大家应该都知道 8086 处理器是一个 16 位处理器，系统总线 20 根，可寻址最大内存空间达 1MB，范围是 00000H-FFFFFH，但其内部的寄存器和 ALU 都只有 16 位，所以在寻址时，需要将段地址乘以 16，再加上偏移地址，以此来实现 20 位的寻址。这都是后话，最主要的是，在 8086 时代，用户可以直接寻址到内存空间的任何位置，这就有可能导致用户错误地修改某些地址值，导致系统崩溃。
由于技术的进步以及人们对多用户操作同一台电脑的需求，在 80386 时代，终于将系统的工作方式给分离了，80386 具有实模式、保护模式和 v68 模式这三种工作模式。其中，实模式其实算是 8086 体系的延续，在该模式下的寻址方式和 8086 无异，这个模式也是为了兼容 16 位体系下的程序。而用户一般所处的状态就是保护模式，在这个模式下可以使用 386 系统的 32 根主线，寻址模式发生根本性的变化，最主要的是引入了特权级的概念，由于我们知道在 8086 时代，随意的内存修改可能导致系统崩溃，而想要避免这种崩溃，就需要把系统内核给保护起来，为此，386 有个 4 个特权级 r0-3，我们的系统内核在最高级别 r0 中，特权级所处的内存空间分置，允许高特权级访问低特权级内存空间，而不允许反向地访问。那么这样一来，确实避免了随意对内存空间的修改，可又引出了一些新的问题，比如系统对外设端口的调用，是通过中断的方式进行的；比如创建新的进程等，这些函数都被内核给把持着，当一个用户想要手动开启这些功能的时候，就遇到了无法访问的问题，这个时候，就需要让低特权级向高特权级发起一个建议，这个建议我们把他叫做系统调用，使用系统调用，就可以让用户在低特权级下使用高特权级的功能。
而这，就是我们第二次实验所要完成的事情。
实验思路讲解 #  大部分思路可以参照官方文档中的 3.2 章节。
在本次实验中，我们需要完成 10 余个系统调用的实现。首先系统调用本质上会落实到函数中，函数需要有参数，而通过计组的学习，我们已经知道，这些参数被放在栈中，当 eip 执行到 call 指令时，会将当前栈顶地址压栈，再将栈底地址赋值给栈顶，而这个时候，参数就被存放在栈底之下。我们的 Pintos 实际上也是类似的操作。">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content="Project 2">
<meta property="og:description" content="Project 2: User Programs #  实验的意义探究 #  我们知道，Pintos 实验旨在通过补充代码，实现一个小型的操作系统。那么这个操作系统，到底是什么级别的系统呢？
这个需要从 Intel 公司的 80x86 系列处理器说起。通过之前计组和系统编程已经学习到的知识，大家应该都知道 8086 处理器是一个 16 位处理器，系统总线 20 根，可寻址最大内存空间达 1MB，范围是 00000H-FFFFFH，但其内部的寄存器和 ALU 都只有 16 位，所以在寻址时，需要将段地址乘以 16，再加上偏移地址，以此来实现 20 位的寻址。这都是后话，最主要的是，在 8086 时代，用户可以直接寻址到内存空间的任何位置，这就有可能导致用户错误地修改某些地址值，导致系统崩溃。
由于技术的进步以及人们对多用户操作同一台电脑的需求，在 80386 时代，终于将系统的工作方式给分离了，80386 具有实模式、保护模式和 v68 模式这三种工作模式。其中，实模式其实算是 8086 体系的延续，在该模式下的寻址方式和 8086 无异，这个模式也是为了兼容 16 位体系下的程序。而用户一般所处的状态就是保护模式，在这个模式下可以使用 386 系统的 32 根主线，寻址模式发生根本性的变化，最主要的是引入了特权级的概念，由于我们知道在 8086 时代，随意的内存修改可能导致系统崩溃，而想要避免这种崩溃，就需要把系统内核给保护起来，为此，386 有个 4 个特权级 r0-3，我们的系统内核在最高级别 r0 中，特权级所处的内存空间分置，允许高特权级访问低特权级内存空间，而不允许反向地访问。那么这样一来，确实避免了随意对内存空间的修改，可又引出了一些新的问题，比如系统对外设端口的调用，是通过中断的方式进行的；比如创建新的进程等，这些函数都被内核给把持着，当一个用户想要手动开启这些功能的时候，就遇到了无法访问的问题，这个时候，就需要让低特权级向高特权级发起一个建议，这个建议我们把他叫做系统调用，使用系统调用，就可以让用户在低特权级下使用高特权级的功能。
而这，就是我们第二次实验所要完成的事情。
实验思路讲解 #  大部分思路可以参照官方文档中的 3.2 章节。
在本次实验中，我们需要完成 10 余个系统调用的实现。首先系统调用本质上会落实到函数中，函数需要有参数，而通过计组的学习，我们已经知道，这些参数被放在栈中，当 eip 执行到 call 指令时，会将当前栈顶地址压栈，再将栈底地址赋值给栈顶，而这个时候，参数就被存放在栈底之下。我们的 Pintos 实际上也是类似的操作。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/p2/"><meta property="article:section" content="docs">
<meta property="article:modified_time" content="2021-11-14T13:58:07+08:00">
<title>Project 2 | OS Pintos Labs</title>
<link rel=manifest href=/os-labs/manifest.json>
<link rel=icon href=/os-labs/favicon.png type=image/x-icon>
<link rel=stylesheet href=/os-labs/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css integrity="sha256-RhgbyTN1upMgJudTs3xA5v+LsWqe93DHi8xmPkV3sbo=" crossorigin=anonymous>
<script defer src=/os-labs/flexsearch.min.js></script>
<script defer src=/os-labs/en.search.min.249b7c700c7553c337f01de796f5df16b1b882c736d772673b6cd43c5e78b88a.js integrity="sha256-JJt8cAx1U8M38B3nlvXfFrG4gsc213JnO2zUPF54uIo=" crossorigin=anonymous></script>
<script defer src=/os-labs/sw.min.f3b6af0beade35f9c86f5d5b080c54bb4c91287aa795367fa753608e508ce5e4.js integrity="sha256-87avC+reNfnIb11bCAxUu0yRKHqnlTZ/p1NgjlCM5eQ=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/os-labs/><span>OS Pintos Labs</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/>Table of Contents</a>
<ul>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/ps0/>Problem Set 0</a>
</li>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/p1/>Project 1</a>
</li>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/table-of-contents/p2/ class=active>Project 2</a>
</li>
</ul>
</li>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/resources/>Resources</a>
<ul>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/resources/weekly-meeting-report/>周例会报告模板</a>
</li>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/resources/install-pintos/>Pintos 环境搭建</a>
</li>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/resources/doc-template/>实验文档模板</a>
</li>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/resources/project01-design-doc/>Project 1 DesignDoc 模板</a>
</li>
<li>
<a href=https://buaa-se-2021.github.io/os-labs/docs/resources/project02-design-doc/>Project 2 DesignDoc 模板</a>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<a href=https://github.com/BUAA-SE-2021/os-labs target=_blank rel=noopener>
Github
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/os-labs/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Project 2</strong>
<label for=toc-control>
<img src=/os-labs/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#project-2-user-programs>Project 2: User Programs</a>
<ul>
<li><a href=#实验的意义探究>实验的意义探究</a></li>
<li><a href=#实验思路讲解>实验思路讲解</a>
<ul>
<li><a href=#前置任务打印进程退出信息>前置任务：打印进程退出信息</a></li>
<li><a href=#任务-1进程参数>任务 1：进程参数</a></li>
<li><a href=#任务-2系统调用>任务 2：系统调用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h1 id=project-2-user-programs>
Project 2: User Programs
<a class=anchor href=#project-2-user-programs>#</a>
</h1>
<h2 id=实验的意义探究>
实验的意义探究
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e7%9a%84%e6%84%8f%e4%b9%89%e6%8e%a2%e7%a9%b6>#</a>
</h2>
<p>我们知道，Pintos 实验旨在通过补充代码，实现一个小型的操作系统。那么这个操作系统，到底是什么级别的系统呢？</p>
<p>这个需要从 Intel 公司的 80x86 系列处理器说起。通过之前计组和系统编程已经学习到的知识，大家应该都知道 8086 处理器是一个 16 位处理器，系统总线 20 根，可寻址最大内存空间达 1MB，范围是 00000H-FFFFFH，但其内部的寄存器和 ALU 都只有 16 位，所以在寻址时，需要将段地址乘以 16，再加上偏移地址，以此来实现 20 位的寻址。这都是后话，最主要的是，在 8086 时代，用户可以直接寻址到内存空间的任何位置，这就有可能导致用户错误地修改某些地址值，导致系统崩溃。</p>
<p>由于技术的进步以及人们对多用户操作同一台电脑的需求，在 80386 时代，终于将系统的工作方式给分离了，80386 具有实模式、保护模式和 v68 模式这三种工作模式。其中，实模式其实算是 8086 体系的延续，在该模式下的寻址方式和 8086 无异，这个模式也是为了兼容 16 位体系下的程序。而用户一般所处的状态就是保护模式，在这个模式下可以使用 386 系统的 32 根主线，寻址模式发生根本性的变化，最主要的是引入了特权级的概念，由于我们知道在 8086 时代，随意的内存修改可能导致系统崩溃，而想要避免这种崩溃，就需要把系统内核给保护起来，为此，386 有个 4 个特权级 r0-3，我们的系统内核在最高级别 r0 中，特权级所处的内存空间分置，允许高特权级访问低特权级内存空间，而不允许反向地访问。那么这样一来，确实避免了随意对内存空间的修改，可又引出了一些新的问题，比如系统对外设端口的调用，是通过中断的方式进行的；比如创建新的进程等，这些函数都被内核给把持着，当一个用户想要手动开启这些功能的时候，就遇到了无法访问的问题，这个时候，就需要让低特权级向高特权级发起一个建议，这个建议我们把他叫做系统调用，使用系统调用，就可以让用户在低特权级下使用高特权级的功能。</p>
<p>而这，就是我们第二次实验所要完成的事情。</p>
<h2 id=实验思路讲解>
实验思路讲解
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e6%80%9d%e8%b7%af%e8%ae%b2%e8%a7%a3>#</a>
</h2>
<p>大部分思路可以参照官方文档中的
<a href=http://web.stanford.edu/class/cs140/projects/pintos/pintos_3.html#SEC40>3.2 章节</a>。</p>
<p>在本次实验中，我们需要完成 10 余个系统调用的实现。首先系统调用本质上会落实到函数中，函数需要有参数，而通过计组的学习，我们已经知道，这些参数被放在栈中，当 <code>eip</code> 执行到 <code>call</code> 指令时，会将当前栈顶地址压栈，再将栈底地址赋值给栈顶，而这个时候，参数就被存放在栈底之下。我们的 Pintos 实际上也是类似的操作。</p>
<p>为了让参数的传递不发生错误，我们首先需要在 <code>process.c</code> 中修改 <code>setup_stack</code> 函数中 <code>*esp = PHYS_BASE</code> 为 <code>*esp = PHYS_BASE-12</code> 。这一步修改的原因会在后续步骤中讲到。</p>
<p>本实验目标是实现系统调用，所以大部分代码都完成在 <code>syscall</code> 函数中，可以看到源代码给了我们一个 <code>syscall_handler</code> 的框架，我们可以在这里将官方文档 3.3.4 中提及的系统调用函数框架搭在这里。</p>
<p>要想执行系统调用，肯定需要参数，前面已经提及，参数被存放在了栈底之下，而在 Pintos 中，这个存放的位置在指针 <code>esp</code> 下，我们通过 <code>syscall</code> 的参数 <code>f</code> 这个栈帧，可以取得对应 <code>esp</code> 指针的值。栈帧 <code>f</code> 是一个名为 <code>intr_frame</code> 的结构，可以在 <code>threads/interrupt.h</code> 文件中找到，从名字我们就可以看出，这是中断时保存的现场，其内部定义了 32 位机器常用的 8 大寄存器的值。<code>esp</code> 就是其中之一。Pintos 文档约定参数最多不超过 3 个，所以由此，我们就可以写出从 <code>esp</code> 位置，获取到参数的函数。</p>
<p>获取完参数，我们就可以正式开始实现系统调用。</p>
<p>从官方文档 3.3.4 中，我们可以看到需要完成的所有系统调用，以及其需要的参数格式，包括其实现方式。</p>
<p>例如第一个 <code>halt()</code> 系统调用，起终止 Pintos 系统的功能，只需要调用 <code>threads/init.h</code> 中的 <code>shutdown_power_off</code> 函数，实现模拟断电即可。</p>
<p>第二个函数 <code>exit(int status)</code>，需要一个返回码的参数，我们都知道，返回码标志着函数进程的退出状态，是否正常退出，这个值最终由父进程回收。我们实现时，只需要从 <code>esp</code> 附近取得这个值，并传递给处理函数即可。</p>
<p>为了验证我们是否成功完成这一系列操作，下一步可以先行实现 <code>write</code> 函数的一部分，即向控制台输出内容，还是根据 3.3.4 的文件内容，我们可以了解到调用 <code>putbuf</code> 函数，即可将内容写入缓冲区，最终输出到控制台，该函数被定义在 <code>lib/kernel/console.c</code> 中，同时当参数 <code>fd</code> 为 1 时，表示需要向控制台输出。<code>write</code> 函数与前两者不一样的是，它需要一个返回值来标志写入的个数，我们需要设计函数的返回值，并将其写入栈帧的 <code>eax</code> 中。</p>
<p>到这里，我们就可以开始尝试过点了，但为了防止 Pintos 的主进程在测试进程结束前就关机，（因为还没有实现 <code>wait</code> 做到父进程等待子进程）所以我们可以在 <code>userprog/process.c</code> 中，将 <code>process_wait</code> 添加一个 <code>sleep</code> 语句，以保证子进程顺利结束。</p>
<p>完成了这些，就可以运行 <code>make check</code>，检查第一个测试用例是否有输出，如果有的话，说明前期的准备都做对了，可以开始一个一个实现系统调用了。</p>
<p>在过点的过程中，大家可以尝试查看测试用例的源代码，以此来获取这些测试用例分别是对应什么系统实现。</p>
<p>我们开始分任务讲解。</p>
<p><strong>开始前的准备</strong></p>
<p>按照实验思路的顺序，</p>
<p>1.首先需要在 <code>process.c</code> 中修改 <code>setup_stack</code> 函数中 <code>*esp = PHYS_BASE</code> 为 <code>*esp = PHYS_BASE-12</code> 。这一步是为了人为给系统调用参数留下空间，防止访问越界。</p>
<p>2.其次是搭建框架，在 <code>syscall.c</code> 函数中，我们可以为 10 余个系统调用搭建框架，以便于以后直接修改函数就能完成。</p>
<p>3.获取参数，我们在系统调用时，需要取得用户传入的参数，我们通过 <code>syscall</code> 的参数 <code>f</code> 这个栈帧，可以取得对应 <code>esp</code> 指针的值。参数就存放在这里，同时数量也可以被设置为一个参数，幸运的是，Pintos 系统调用约定参数不超过 3 个。</p>
<p>4.实现简单的 <code>exit</code>，为了能让进程顺利结束，肯定需要先完成退出，我们在 <code>syscall.c</code> 中，只需要调用 <code>thread_exit()</code>; 就可以实现简单的退出。</p>
<p>5.向 console 打印信息，测试点的输出结果是靠用户调用 <code>write</code> 这一系统调用完成的，所以想要成功获得过点情况，就需要先实现一部分 <code>write</code> 调用。根据 3.3.4 的文件内容，我们可以了解到调用 <code>putbuf</code> 函数，即可将内容写入缓冲区，最终输出到控制台，该函数被定义在 <code>lib/kernel/console.c</code> 中，同时当参数 <code>fd</code> 为 1 时，表示需要向控制台输出。<code>write</code> 函数与前两者不一样的是，它需要一个返回值来标志写入的个数，我们需要设计函数的返回值，并将其写入栈帧的 <code>eax</code> 中。</p>
<p>6.防止 <code>wait</code> 的立即结束。为了防止 Pintos 的主进程在测试进程结束前就关机，（因为还没有实现 <code>wait</code> 做到父进程等待子进程）所以我们可以在 <code>userprog/process.c</code> 中，将 <code>process_wait</code> 添加一个 <code>sleep</code> 语句，以保证子进程顺利结束。</p>
<h3 id=前置任务打印进程退出信息>
前置任务：打印进程退出信息
<a class=anchor href=#%e5%89%8d%e7%bd%ae%e4%bb%bb%e5%8a%a1%e6%89%93%e5%8d%b0%e8%bf%9b%e7%a8%8b%e9%80%80%e5%87%ba%e4%bf%a1%e6%81%af>#</a>
</h3>
<p>Pintos 要求每一次退出时都打印退出代码，没有这个打印行为，几乎所有的点都无法通过，但其本身没有点。首先我们需要在 <code>threads/thread.h</code> 函数中修改 <code>thread</code> 结构体，为其添加退出码这个值，其次我们在系统调用 <code>exit</code> 时，需要将退出码存储在结构体中，最后在 <code>userprog/process.c</code> 中 <code>process_exit()</code> 函数中按文档所给的格式（见 3.3.2）打印退出码。（这里需要解释一点，Pintos 实验做到这里时，仍没有区分线程和进程的概念，一定程度上可以混用）。</p>
<h3 id=任务-1进程参数>
任务 1：进程参数
<a class=anchor href=#%e4%bb%bb%e5%8a%a1-1%e8%bf%9b%e7%a8%8b%e5%8f%82%e6%95%b0>#</a>
</h3>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>args-none</td>
<td>命令没有任何的参数，检查第 0 个参数是不是文件名，运行命令为 <code>args-none</code>。</td>
</tr>
<tr>
<td>2</td>
<td>args-single</td>
<td>有一个参数，检查参数数量和内容是否正确，运行命令为 <code>args-single onearg</code>。</td>
</tr>
<tr>
<td>3</td>
<td>args-multiple</td>
<td>一共有 4 个参数，运行命令为 <code>args-multiple some arguments for you!</code>。</td>
</tr>
<tr>
<td>4</td>
<td>args-many</td>
<td>一共有 22 各参数，运行命令为 <code>args-many a b c d e f g h i j k l m n o p q r s t u v</code>。</td>
</tr>
<tr>
<td>5</td>
<td>args-dbl-space</td>
<td>有参数用两个空格间隔，确保要识别正确，运行命令为 <code>args-dbl-space two spaces!</code>。不需要特别在意这个。</td>
</tr>
</tbody>
</table>
<p>上表是该任务对应的点以及分别在考察什么。</p>
<p>第一个任务，实际上较为复杂，我们需要观察进程的创建过程，在 <code>process.c</code> 的 <code>process_execute</code> 即为我们的线程创建函数。其中 <code>file_name</code> 就是我们传递进来的参数，但是它不仅包含了我们要执行的函数，也包括了后面的参数，所以这里需要进行字符串分割。幸运的是，Pintos 已经为我们提供了一个字符串分割的函数，声明在 <code>lib/string.h</code> 中。</p>
<p>分割完参数后，可以看到进程拉起了一个线程，我们需要在线程的创建函数中 <code>start_process</code> 中，将参数放置于 <code>esp</code> 的对应位置。堆栈结构请参照 3.5.1。</p>
<table>
<thead>
<tr>
<th>Address</th>
<th>Name</th>
<th>Data</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xbffffffc</td>
<td><code>argv[3][...]</code></td>
<td><code>"bar\0"</code></td>
<td><code>char[4]</code></td>
</tr>
<tr>
<td>0xbffffff8</td>
<td><code>argv[2][...]</code></td>
<td><code>"foo\0"</code></td>
<td><code> char[4]</code></td>
</tr>
<tr>
<td>0xbffffff5</td>
<td><code>argv[1][...]</code></td>
<td><code>"-1\0"</code></td>
<td><code> char[3]</code></td>
</tr>
<tr>
<td>0xbfffffed</td>
<td><code>argv[0][...]</code></td>
<td><code>"/bin/ls\0"</code></td>
<td><code> char[8]</code></td>
</tr>
<tr>
<td>0xbfffffec</td>
<td><code>word-align</code></td>
<td><code>0</code></td>
<td><code>uint8_t</code></td>
</tr>
<tr>
<td>0xbfffffe8</td>
<td><code>argv[4]</code></td>
<td><code>0</code></td>
<td><code>char *</code></td>
</tr>
<tr>
<td>0xbfffffe4</td>
<td><code>argv[3]</code></td>
<td><code>0xbffffffc</code></td>
<td><code>char *</code></td>
</tr>
<tr>
<td>0xbfffffe0</td>
<td><code>argv[2]</code></td>
<td><code>0xbffffff8</code></td>
<td><code>char *</code></td>
</tr>
<tr>
<td>0xbfffffdc</td>
<td><code>argv[1]</code></td>
<td><code>0xbffffff5</code></td>
<td><code>char *</code></td>
</tr>
<tr>
<td>0xbfffffd8</td>
<td><code>argv[0]</code></td>
<td><code>0xbfffffed</code></td>
<td><code>char *</code></td>
</tr>
<tr>
<td>0xbfffffd4</td>
<td><code>argv</code></td>
<td><code>0xbfffffd8</code></td>
<td><code>char **</code></td>
</tr>
<tr>
<td>0xbfffffd0</td>
<td><code>argc</code></td>
<td><code>4</code></td>
<td><code>int</code></td>
</tr>
<tr>
<td>0xbfffffcc</td>
<td><code>return address</code></td>
<td><code>0</code></td>
<td><code>void (*)()</code></td>
</tr>
</tbody>
</table>
<p>同学们可参照压栈图，将分割出的参数压栈到中断现场的合适位置。</p>
<p><strong>Tip 1：</strong></p>
<p>如果在实现该部分过程中，传递的参数始终有问题，请注意分割 <code>fn_copy</code> 的位置和传递给 <code>start_process</code> 的顺序，或者每次使用时，都重新 <code>memcpy</code> 拷贝一份，以防止修改到原始的数据。</p>
<p>做到这里，还记得我们前面的 <code>*esp = PHYS_BASE-12;</code> 吗？这个时候已经处理好压栈，就可以删去 <code>-12</code> 了。现在明白为什么要 <code>-12</code> 了吗？是为了防止在为传递参数的时候，错误地移动指针，访问到不应该访问或修改的内存值。</p>
<h3 id=任务-2系统调用>
任务 2：系统调用
<a class=anchor href=#%e4%bb%bb%e5%8a%a1-2%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8>#</a>
</h3>
<h4 id=21-调用参数所处内存地址>
2.1 调用参数所处内存地址
<a class=anchor href=#21-%e8%b0%83%e7%94%a8%e5%8f%82%e6%95%b0%e6%89%80%e5%a4%84%e5%86%85%e5%ad%98%e5%9c%b0%e5%9d%80>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>sc-bad-sp</td>
<td>将 <code>esp</code> 指向非法的地方之后触发系统调用，正常情况下应该 <code>exit(-1)</code>。测试用例是利用内联汇编来实现的。</td>
</tr>
<tr>
<td>7</td>
<td>sc-bad-arg</td>
<td>将 <code>esp</code> 指向了栈顶下 4 字节（刚好放进了 <code>exit</code> 的系统调用号），试图在获取系统调用的参数时访问非法的内存区域，正常情况下应该以 exit(-1) 退出。</td>
</tr>
<tr>
<td>8</td>
<td>sc-boundary</td>
<td>让 <code>exit</code> 的系统调用号和参数正好放在页边界，观察退出状态值是否正常。不需要特别在意这个。</td>
</tr>
<tr>
<td>9</td>
<td>sc-boundary-2</td>
<td>让 <code>exit</code> 的参数的前三个字节和最后一个字节存放在页边界，观察退出状态值是否正常。不需要特别在意这个。</td>
</tr>
</tbody>
</table>
<p>该任务的目的是，检查我们传递的参数的内存地址，正如我们在实验目的里阐述的，使用特权级的目的是保护内存，这里也是一样，Pintos 将 kernel 和用户内存空间分成了两部分，如下图所示，BASE 以上是内存空间，08048000-BASE 之间，才是用户进程空间，如果一个指针，指向了没有权限的位置，就应该直接以 -1 退出。文档的 3.1.5 部分给我们提供了两种思路，一种是 <code>userprog/pagedir.c</code> 和在 <code>threads/vaddr.h</code> 中的相关函数 <code>pagedir_get_page</code>，来验证地址范围，一种是通过访问该地址，来造成 <code>page_fault</code>，在 <code>page_fault</code> 处理函数中，再退出。</p>
<pre tabindex=0><code>PHYS_BASE +----------------------------------+
            |            user stack            |
            |                 |                |
            |                 |                |
            |                 V                |
            |          grows downward          |
            |                                  |
            |                                  |
            |                                  |
            |                                  |
            |           grows upward           |
            |                 ^                |
            |                 |                |
            |                 |                |
            +----------------------------------+
            | uninitialized data segment (BSS) |
            +----------------------------------+
            |     initialized data segment     |
            +----------------------------------+
            |           code segment           |
0x08048000 +----------------------------------+
            |                                  |
            |                                  |
            |                                  |
            |                                  |
            |                                  |
        0 +----------------------------------+

</code></pre><p><strong>Tip 2：</strong></p>
<p>这里一定要记得，参数的地址不一定是连续的，而且每个参数的地址都是 4 个 byte，注意有可能一个参数地址一半跨越界限，一半不跨越的情况。</p>
<h4 id=22-打开关闭文件>
2.2 打开关闭文件
<a class=anchor href=#22-%e6%89%93%e5%bc%80%e5%85%b3%e9%97%ad%e6%96%87%e4%bb%b6>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>19</td>
<td>open-normal</td>
<td>正常打开一个文件，如果 <code>fd>2</code> 则 pass。</td>
</tr>
<tr>
<td>20</td>
<td>open-missing</td>
<td>打开不存在的文件，<code>fd</code> 应为 -1。</td>
</tr>
<tr>
<td>21</td>
<td>open-empty</td>
<td>文件名为空字符串，<code>fd</code> 应为 -1。</td>
</tr>
<tr>
<td>22</td>
<td>open-boundary</td>
<td>文件名跨页，看是否能正常打开。不需要特别在意这个。</td>
</tr>
<tr>
<td>23</td>
<td>open-null</td>
<td>文件名使用 <code>NULL</code>，应该以 <code>exit(-1)</code> 退出。</td>
</tr>
<tr>
<td>24</td>
<td>open-bad-ptr</td>
<td>文件名指针处于用户空间，但是指向了未分配的区域，应该以 <code>exit(-1)</code> 退出。</td>
</tr>
<tr>
<td>25</td>
<td>open-twice</td>
<td>打开同一个文件两次，观察是否能正常打开且 <code>fd</code> 是不是不一样（要求不一样）。</td>
</tr>
<tr>
<td>26</td>
<td>close-normal</td>
<td>正常关闭一个文件，看程序是否正常退出。</td>
</tr>
<tr>
<td>27</td>
<td>close-twice</td>
<td>关闭两次同一个 <code>fd</code>，正常退出或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>28</td>
<td>close-stdin</td>
<td>关闭标准输入流，正常退出或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>29</td>
<td>close-stdout</td>
<td>关闭标准输出流，正常退出或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>30</td>
<td>close-bad-fd</td>
<td>关闭不存在的 <code>fd</code>，正常退出或者以 -1 退出都可以。</td>
</tr>
</tbody>
</table>
<p>这一块是过点的集中地，很容易写完后过许多点，收获做实验的满足感。</p>
<p>相信做过 Project 1 的同学们对 Pintos 中的链表结构都不陌生了，我们可以使用链表（如果愿意的话你也可以使用数组）来维护打开的文件列表，同时按我们已有的知识，，每一个打开的文件都需要有一个文件描述符 <code>fd</code>，且 <code>fd</code> 在不同进程中不共享，所以可见是由进程维护描述符，同时，0，1，2 三个描述符已经默认分配，所以我们必须从 3 开始为新打开的文件分配描述符。</p>
<p><strong>Tip 3：</strong></p>
<p>实验过点的文件不会打开很多，所以不需要考虑关闭文件后，描述符的重新利用。</p>
<p>同理，打开一个文件需要文件地址，这个地址，也是需要我们进行地址判断，防止其越界。到了这里，我们就可以使用 <code>filesys/filesys.c</code> 中定义的 <code>filesys_open</code> 来完成 <code>open</code> 的系统调用了。同时也要在进程中维护打开的文件列表。</p>
<p>关闭也是同理，我们需要将维护的文件及其描述符从进程的文件列表中移除，并使用 <code>file_close</code> 关闭该文件。</p>
<p><strong>Tip 4：</strong></p>
<p>在维护打开文件元素时，使用了 <code>malloc</code> 的话，记得一定要在关闭时释放，这一点对于后面的某个点至关重要。同时注意，在一个进程退出时，也应该关闭其打开的所有文件。</p>
<h4 id=23-创建移除文件>
2.3 创建移除文件
<a class=anchor href=#23-%e5%88%9b%e5%bb%ba%e7%a7%bb%e9%99%a4%e6%96%87%e4%bb%b6>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>create-normal</td>
<td>正常创建一个文件，然后用 <code>open</code> 系统调用看是否能打开。</td>
</tr>
<tr>
<td>13</td>
<td>create-empty</td>
<td>创建文件名为空的文件，返回创建失败或直接以 -1 退出。</td>
</tr>
<tr>
<td>14</td>
<td>create-null</td>
<td>创建的文件名为 <code>NULL</code>，要求以 -1 退出。</td>
</tr>
<tr>
<td>15</td>
<td>create-bad-ptr</td>
<td>创建的文件名指向未分配空间，返回创建失败或直接以 -1 退出。</td>
</tr>
<tr>
<td>16</td>
<td>create-long</td>
<td>创建一个文件名很长的文件。不用特别在意他。</td>
</tr>
<tr>
<td>17</td>
<td>create-exists</td>
<td>创建重名的文件，返回创建失败即可。</td>
</tr>
<tr>
<td>18</td>
<td>create-bound</td>
<td>创建的文件名跨页。不用特别在意他。</td>
</tr>
</tbody>
</table>
<p>这一部分较为简单，创建文件调用 <code>filesys/filesys.c</code> 中定义的 <code>filesys_create</code> 即可，移除调用 <code>filesys/filesys.c</code> 中定义的 <code>filesys_remove</code>。</p>
<h4 id=24-读写文件>
2.4 读写文件
<a class=anchor href=#24-%e8%af%bb%e5%86%99%e6%96%87%e4%bb%b6>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>31</td>
<td>read-normal</td>
<td>正常读取文件，比对读取的内容是否正确。</td>
</tr>
<tr>
<td>32</td>
<td>read-bad-ptr</td>
<td>存放读取内容的 <code>buffer</code> 指向了没被映射的地址，返回 0 或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>33</td>
<td>read-boundary</td>
<td><code>buffer</code> 跨页，不需要特别在意他。</td>
</tr>
<tr>
<td>34</td>
<td>read-zero</td>
<td>读取 <code>size = 0</code> 的内容。</td>
</tr>
<tr>
<td>35</td>
<td>read-stdout</td>
<td>试图读取标准输出流，返回 0 或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>36</td>
<td>read-bad-fd</td>
<td>读取不存在的 <code>fd</code>，返回 0 或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>37</td>
<td>write-normal</td>
<td>正常写入文件，判断返回值是否正确。</td>
</tr>
<tr>
<td>38</td>
<td>write-bad-ptr</td>
<td>写入读取内容的 <code>buffer</code> 指向了没被映射的地址，返回 0 或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>39</td>
<td>write-boundary</td>
<td><code>buffer</code> 跨页，不需要特别在意他。</td>
</tr>
<tr>
<td>40</td>
<td>write-zero</td>
<td>写入 0 byte 的内容。</td>
</tr>
<tr>
<td>41</td>
<td>write-stdin</td>
<td>试图写入标准输入流，返回 0 或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>42</td>
<td>write-bad-fd</td>
<td>写入不存在的 <code>fd</code>，返回 0 或者以 -1 退出都可以。</td>
</tr>
</tbody>
</table>
<p>和创建移除一样，比较简单，参照 <code>3.3.4</code> 的参数格式，同时对于 <code>write</code>，我们已经实现了向终端写入。<code>read</code> 会用到 <code>input_getc()</code>与 <code>file_read()</code>，<code>write</code> 会用到 <code>file_write()</code>与 <code>putbuf()</code>。</p>
<p><strong>Tip 5：</strong></p>
<p>这里除了注意参数是否和法外，还需要判断缓冲区是否合法。</p>
<h4 id=25-执行与等待>
2.5 执行与等待
<a class=anchor href=#25-%e6%89%a7%e8%a1%8c%e4%b8%8e%e7%ad%89%e5%be%85>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>43</td>
<td>exec-once</td>
<td>创建一个子进程，观察子进程退出代码（81），以及父进程退出代码是否正确（0）。</td>
</tr>
<tr>
<td>44</td>
<td>exec-arg</td>
<td>执行的子进程有多个参数，观察参数是否正确。</td>
</tr>
<tr>
<td>45</td>
<td>exec-multiple</td>
<td><code>wait(exec(…)</code>)五次，观察退出代码以及退出顺序。</td>
</tr>
<tr>
<td>46</td>
<td>exec-missing</td>
<td>执行不存在的文件，观察 <code>exec</code> 返回值（-1）。</td>
</tr>
<tr>
<td>47</td>
<td>exec-bad-ptr</td>
<td>执行的命令指向未被分配的内存区域，返回 0 或者以 -1 退出都可以。</td>
</tr>
<tr>
<td>48</td>
<td>wait-simple</td>
<td><code>wait</code> 一个子进程，观察返回值是否和子进程的退出代码一致（81）。</td>
</tr>
<tr>
<td>49</td>
<td>wait-twice</td>
<td>等待两次同一个子进程，第二次等待应该返回 -1。</td>
</tr>
<tr>
<td>50</td>
<td>wait-killed</td>
<td>等待一个子进程，子进程刚执行就被 kill 杀死（应该以 -1 退出），观察子进程退出代码以及父进程在 <code>wait</code> 后的返回值。</td>
</tr>
<tr>
<td>51</td>
<td>wait-bad-pid</td>
<td><code>wait</code> 一个不存在的 PID。</td>
</tr>
</tbody>
</table>
<p>该部分为创建子进程和父进程等待子进程并回收，也是一个难点。</p>
<p>这里我们还需要提到前面讲过的一点，Pintos 在这里还没有特别区分进程和线程的概念，可以理解为一个线程就是一个进程，所以其 ID 可以一一映射。该部分的重点在于父进程需要维护创建的子进程列表。子进程的创建过程其实就是我们前面修改过的 <code>process_execute()</code> 函数。注意到在该函数的 <code>thread_create</code> 函数执行后，其实子进程就已经转移到 <code>start_process</code> 中开始运行或者加入就绪队列了。这里我们要保证子进程一定成功创建，就需要实现一个同步锁，来保证子进程 <code>load</code> 成功才接着执行父进程，子进程一旦创建失败，说明该该调用失败了。</p>
<p>而对于 <code>wait</code> 操作，很明显也需要一个锁，保证父进程在子进程执行期间无法进行任何操作，等待子进程退出后，父进程获取子进程退出码，并回收资源。这里的锁的设计非常精妙，要保证父进程 <code>wait</code> 时，无法执行任何操作，子进程退出时，需要立刻通知父进程，但不能直接销毁，而要等待父进程来回收资源获取返回码等，然后才可以正常销毁。需要几个锁来完成这个操作，同学们可以好好考虑。</p>
<h4 id=26-multi>
2.6 multi
<a class=anchor href=#26-multi>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>52</td>
<td>multi-recurse</td>
<td>递归创建子进程，共 16 个，观察进入和退出的顺序。</td>
</tr>
<tr>
<td>53</td>
<td>multi-child-fd</td>
<td>子进程尝试关闭一个父进程打开的文件（应该要失败），之后看父进程还能不能正常访问这个文件。</td>
</tr>
</tbody>
</table>
<p>这一部分几乎没有需要多写的，只需要完成 <code>filesize</code> 这个系统调用。</p>
<p><code>filesize </code>在文档中的声明为：<code>int filesize (int fd);</code></p>
<p>所以需要我们用 <code>fd</code> 去寻找打开的文件。实现时调用 <code>file_length</code> 就行。</p>
<h4 id=27-rox>
2.7 rox
<a class=anchor href=#27-rox>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>54</td>
<td>rox-simple</td>
<td>尝试改写自己的可执行文件（<code>write</code> 应该要返回 0）。</td>
</tr>
<tr>
<td>55</td>
<td>rox-child</td>
<td>父进程先写好子进程的可执行文件，然后执行子进程。接下来子进程尝试改写自己的可执行文件（<code>write</code> 应该要返回 0），之后会退出。然后父进程再次改写子进程的可执行文件（应该要成功）。</td>
</tr>
<tr>
<td>56</td>
<td>rox-multichild</td>
<td>父进程先写好子进程的可执行文件，然后递归地创建 5 个子进程且他们都试图改写自己的可执行文件；然后递归地退出，退出前也试图改写自己的可执行文件；最后一次父进程会再次改写子进程的可执行文件（这次应该要成功）。</td>
</tr>
</tbody>
</table>
<p>这一部分旨在防止进程修改正在运行的可执行文件，详见文档中的 3.3.5</p>
<p>可执行文件在 Pintos 中的定义为用来创建进程的文件，即创建进程时打开的那一个文件。<code>filesys/file.c</code> 文件中定义了函数 <code>file_deny_write()</code>，该函数可以禁止对文件的写操作。我们需要在 <code>load</code> 时，禁止对该文件的写操作，在退出时回复。</p>
<p>同时这一块需要实现 <code>seek</code> 调用。需要用到 <code>file_seek()</code> 函数。</p>
<h4 id=28-bad>
2.8 bad
<a class=anchor href=#28-bad>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>57</td>
<td>bad-read</td>
<td>读取 <code>NULL</code> 指针的内容。</td>
</tr>
<tr>
<td>58</td>
<td>bad-write</td>
<td>给 <code>NULL</code> 指针的位置赋值。</td>
</tr>
<tr>
<td>59</td>
<td>bad-read2</td>
<td>读取内核空间的内容。</td>
</tr>
<tr>
<td>60</td>
<td>bad-write2</td>
<td>往内核空间赋值。</td>
</tr>
<tr>
<td>61</td>
<td>bad-jump</td>
<td>把 <code>NULL</code> 伪装成函数后调用。</td>
</tr>
<tr>
<td>62</td>
<td>bad-jump2</td>
<td>把内核空间地址伪装成函数后调用。</td>
</tr>
</tbody>
</table>
<p>这一部分，理论上要是做到了前面的每个地址访问都验证地址合法性，是可以直接通过的。如果有不通过，除了补充前面的不足外，由于访问非法地址会引起 <code>page_fault</code>，所以我们可以在 <code>exception.c</code> 中对 <code>page_fault()</code>进行修改，在 kill 时结束进程，返回 -1.</p>
<h4 id=29-资源释放>
2.9 资源释放
<a class=anchor href=#29-%e8%b5%84%e6%ba%90%e9%87%8a%e6%94%be>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>63</td>
<td>multi-oom</td>
<td>全实验最难的一个点，但也有可能是最简单的一个点。</td>
</tr>
</tbody>
</table>
<p>该部分旨在探究同学们编码过程中，对于资源的合理理由，务必要做到每一个资源申请后，都会有释放。包括前面提到的文件的退出，消除开辟的内存空间，同时注意到进程退出时，关闭所有打开的文件，以及 <code>open</code>、<code>close</code>、<code>create</code>、<code>remove</code>、<code>execute</code>、<code>wait</code> 等所有过程中开辟的空间都需要关闭。</p>
<p>
<img src=RackMultipart20211114-4-10xwaiu_html_280ac6c04c136598.png alt></p>
<h4 id=210-文件系统>
2.10 文件系统
<a class=anchor href=#210-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a>
</h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>测试点</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>lg-create</td>
<td>创建一个大的空白文件，检查文件大小与内容是否是合格的。</td>
</tr>
<tr>
<td>65</td>
<td>lg-full</td>
<td>创建一个大的文件，在里面填满内容，检查文件的大小与内容是否和期望的一致。</td>
</tr>
<tr>
<td>66</td>
<td>lg-random</td>
<td>创建一个大的文件，往里边多次随机写入内容，然后读取内容比对。</td>
</tr>
<tr>
<td>67</td>
<td>lg-seq-block</td>
<td>创建一个大的文件，以 <code>block_size</code> 为单位多次写入内容，然后读取内容进行比对。</td>
</tr>
<tr>
<td>68</td>
<td>lg-seq-random</td>
<td>与上一个相比，<code>block_size</code> 变为了随机数。</td>
</tr>
<tr>
<td>69</td>
<td>sm-create</td>
<td>创建一个小的空白文件，检查文件大小与内容是否是合格的。</td>
</tr>
<tr>
<td>70</td>
<td>sm-full</td>
<td>创建一个小的文件，在里面填满内容，检查文件的大小与内容是否和期望的一致。</td>
</tr>
<tr>
<td>71</td>
<td>sm-random</td>
<td>创建一个小的文件，往里边多次随机写入内容，然后读取内容比对。</td>
</tr>
<tr>
<td>72</td>
<td>sm-seq-block</td>
<td>创建一个小的文件，以 <code>block_size</code> 为单位多次写入内容，然后读取内容进行比对。</td>
</tr>
<tr>
<td>73</td>
<td>sm-seq-random</td>
<td>与上一个相比，<code>block_size</code> 变为了随机数。</td>
</tr>
<tr>
<td>74</td>
<td>syn-read</td>
<td>创建 10 个进程，打开同一个文件并一个字节一个字节地比对内容，保证中途没有异常发生（打开文件失败等情况）。</td>
</tr>
<tr>
<td>75</td>
<td>syn-remove</td>
<td>打开一个文件后移除文件，确认文件是否仍然可读写。</td>
</tr>
<tr>
<td>76</td>
<td>syn-write</td>
<td>比起 <code>syn-read</code>，读变成了写，但只写一次。</td>
</tr>
</tbody>
</table>
<p>其中 74-76 涉及到了文件的锁，我们需要对文件系统设计一个锁，在所有用到的操作中，操作前都上锁，操作后都去除锁，基本上就可以实现。这一部分的修改在 <code>filesys.h</code> 和 <code>filesys.c</code> 中完成。</p>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
<div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/60a1117237bdb4efa4456bb15f9cb02a9865f62c title="Last modified by Yinghao Zhu | November 14, 2021" target=_blank rel=noopener>
<img src=/os-labs/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 14, 2021</span>
</a>
</div>
<div>
<a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/docs/table-of-contents/p2.md target=_blank rel=noopener>
<img src=/os-labs/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span>
</a>
</div>
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#project-2-user-programs>Project 2: User Programs</a>
<ul>
<li><a href=#实验的意义探究>实验的意义探究</a></li>
<li><a href=#实验思路讲解>实验思路讲解</a>
<ul>
<li><a href=#前置任务打印进程退出信息>前置任务：打印进程退出信息</a></li>
<li><a href=#任务-1进程参数>任务 1：进程参数</a></li>
<li><a href=#任务-2系统调用>任务 2：系统调用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>