[{"id":0,"href":"/os-labs/docs/table-of-contents/ps0/","title":"Problem Set 0","section":"Table of Contents","content":"Problem Set 0 #  实验说明 #   单人完成，代码要求每人一份（只需提交两个 *.c文件）。除代码外，还需要提交文档。内容可为设计和需求说明、解决思路等，无文档模板，自由发挥。 对于每个人而言，请仅提交一个 PDF 文件（如果有多个文档，请合并成一个。推荐把所有内容写在一个 Markdown/LaTex 项目里）。由组长将每个人的代码文件和 PDF 文档收齐后，将每个人的提交内容放在各自的文件夹后打包为 Zip 包提交。 本次实验因为不涉及多人合作，故对 Git 的使用没有要求。此后的 Project 1 开始，会对小组使用 Git 的情况进行考察。 本实验需要利用操作系统的同步机制，实现问题中要求的逻辑功能。 实验代码可在官网中自行下载，无需 Pintos 环境即可直接运行。  实验内容 #   Problem 1：自动化车站  乘客行为：到站台等车、车来则上车 火车行为：到站装载乘客，无人等待或车已满就开走 让乘客和火车的行为流畅运行，以实现车站的自动化管理   Problem 2：氢原子与氧原子结合，生成 H2O  2 个 H 和 1 个 O 生成水分子 如何保证 H2O 结构正常生成，不会遗漏或多加原子    Problem 1 #  需求 #  CalTrain 程序想让你通过自动化列车和乘客管理来提高效率。每名乘客和每列火车都由一个线程控制。 要求编写同步函数，以确保列车的有序装载。避免出现多人上车座位不够的情况。\n步骤 #   定义 station 结构体  包含程序所用的信号量、锁、条件变量   编写以下处理函数：  初始化函数：station_init(struct station *station) 初始化结构体中的数据   列车行为：  火车到站打开车门：station_load_train(struct station *station, int count) 当且仅当列车已满或无乘客等待时，该函数返回   乘客行为：  到站等车，添加一名位于等待状态的乘客：station_wait_for_train(struct station *station) 乘客就坐，“通知”列车当前乘客已经就坐：station_on_board(struct station *station)   外层调用无需考虑，只需定义结构体和同步机制所需的函数  要求 #   允许多名乘客等车 只需改动 caltrain.c 不能造成忙等待 只能使用以下函数  lock_init (struct lock *lock) lock_acquire(struct lock *lock) lock_release(struct lock *lock) cond_init(struct condition *cond) cond_wait(struct condition *cond, struct lock *lock) cond_signal(struct condition *cond, struct lock *lock) cond_broadcast(struct condition *cond, struct lock *lock)    Problem 2 #  需求 #  大自然母亲聘请你帮助她解决形成水的化学反应，但是她似乎无法正确处理反应中的同步问题。 将两个 H 原子和一个 O 原子同时放在一起即可生成水分子， 每个原子由一个线程表示。\n步骤 #   定义 reaction 结构体 包含程序所用的信号量、锁、条件变量 编写以下处理函数：  初始化函数：reaction_init(struct reaction *r) 氢氧原子准备结合：void reaction_h(struct reaction *r)、void reaction_o(struct reaction *r) 每有一个 H 或 O 原子进入等待，调用该函数，结合成功后返回   在代码中包含结合水的函数：make_water()  无需实现，已经给出，需要在逻辑中加入    要求 #   允许多个原子等待反应 不能造成忙等待 只需改动 reation.c 只能使用以下函数  lock_init (struct lock *lock) lock_acquire(struct lock *lock) lock_release(struct lock *lock) cond_init(struct condition *cond) cond_wait(struct condition *cond, struct lock *lock) cond_signal(struct condition *cond, struct lock *lock) cond_broadcast(struct condition *cond, struct lock *lock)    测试方法 #   在代码根目录下命令行运行 make run 重新编译记得 make clean  正常运行时命令行输出：\n...Train departed station with 17 new passenger(s) (expected 17) Looks good! ./reaction 0 Created 0 H and 200 O atoms (0.0% H), expecting 0 H2O molecules Looks good! "},{"id":1,"href":"/os-labs/docs/resources/weekly-meeting-report/","title":"周例会报告模板","section":"Resources","content":"周例会报告 #  会议基本信息 #   会议日期： 时间： 参会人员： 地点： 记录人： 会议主题：  规划议程 #  会议内容 #   简述会议实际进程，突出谁发现了什么问题，谁解决了什么问题，并是怎么解决的\n 下一阶段目标和打算 #  参会人员小结 #  空白模板 #  # 周例会报告 ## 会议基本信息  - 会议日期： - 时间： - 参会人员： - 地点： - 记录人： - 会议主题： ## 规划议程  ## 会议内容 \u0026gt; 简述会议实际进程，突出谁发现了什么问题，谁解决了什么问题，并是怎么解决的  ## 下一阶段目标和打算  ## 参会人员小结 参考的填写模板 #  # 周例会报告 ## 会议基本信息  - 会议日期：20210930 - 时间：15:00-18:00 - 参会人员：zzj、hhz、wyh、lrq - 地点：腾讯会议、新主楼 - 记录人：zyh - 会议主题：开始实验前任务布置 ## 规划议程  - 15:00-16:00 一起读题 - 16:00-17:00 讨论解决思路 - 17:00-18:00 看代码，debug ## 会议内容  zzj 带领我们看了一下代码的结构，根据助教的提示明确了实验内容要做什么。 wyh 发现在 `xx.h` 里，需要定义一个新的结构体，因为 `xxx.c` 里要用，我们要通过它来实现同步。 lrq 认为`void` 的使用还难，我们一起查了下网上博客，发现他的用法有 xxx。 会议的最后，hhz 给 zzj、wyh、lrq 倒了杯卡布奇诺，说“兄弟们，辛苦了”。 ## 下一阶段目标和打算  提前做完实验，下一周讨论一下 Project 2 怎么搞。 ## 各参会人员小结  ### zzj  今天我带领了组内成员读了题目，解决了重要 BUG，顺利 AK。 ### hhz  ... "},{"id":2,"href":"/os-labs/docs/resources/install-pintos/","title":"Pintos 环境搭建","section":"Resources","content":"Pintos 环境搭建 #   Author: Muyung, YinghaoZhu\n 另外，感谢李宇轩（huahuaxiaomuzhu）同学提供在 Docker 中配置 Pintos 的方法。详见 pintos-docker。张开颜同学的配置方法也可以参考 buaa_pintos。\n依赖安装 #  我所使用的实验环境为 VMware Workstation 16 Player (免费) 上运行的 Ubuntu 16.04 64 位版本（32 位版本不可以）。\n  Download VMware Workstation 16 Player  Download Ubuntu 16.04  选择 ubuntu-16.04.7-desktop-amd64.iso    安装 GNU binutils #  安装成功后，终端运行 i386-elf-objdump -i，应输出：\nBFD header file version (GNU Binutils) 2.21.1 elf32-i386 (header little endian, data little endian) i386... 如果未出现这一信息，则需要安装 binutils ：\n首先下载该依赖包：终端执行 wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2\n解压并安装：\ntar xjf binutils-2.21.1.tar.bz2 cd binutils-2.21.1 ./configure --prefix=/usr/local --target=i386-elf --disable-werror make sudo make install # 这一步权限必不可少 cd .. 安装 Bochs #  这里采用的 Bochs 版本是 2.6.7，而非 Pintos 推荐的 2.2.6，因为过旧版本的 bochs 已经无法通过新版本 gcc 的编译。\n这里先将可能用到的依赖都安装验证一遍：\nsudo apt-get update # 更新 apt 库 sudo apt-get -y install build-essential # -y 参数自动确认 (Y/n) sudo apt-get -y install xorg-dev sudo apt-get -y install bison sudo apt-get -y install libgtk2.0-dev sudo apt-get -y install libc6:i386 libgcc1:i386 libstdc++5:i386 libstdc++6:i386 sudo apt-get -y install libncurses5:i386 sudo apt-get -y install g++-multilib  下载 bochs02.6.7 链接\n点击\u0026quot;bochs-2.6.7.tar.gz\u0026quot;下载，解压并安装（其与 Pintos 都已上传至 BUAA-SE-2021 pintos 仓库的 materials 文件夹下，可一起压缩后拖到虚拟机里去再解压，直接拖文件夹会比较慢）：\ntar xzf bochs-2.6.7.tar.gz cd bochs-2.6.7 chmod +x ./configure # 赋可执行权限 ./configure --enable-gdb-stub make sudo make install # 这一步权限必不可少 Pintos 安装 #  解压该 Ubuntu 16 所对应版本的 Pintos\ntar xzf pintos.tar.gz 复制脚本 #  这一步需要把 pintos/src/utils 文件夹下的诸多脚本文件添加到环境变量 PATH 下，这里直接将它们复制至 /usr/bin 文件夹下。\ncd ~/pintos/src/utils # 进入 Pintos 所在的文件夹，此处为家目录 sudo cp backtrace /usr/bin sudo cp pintos /usr/bin sudo cp pintos-gdb /usr/bin sudo cp pintos-mkdisk /usr/bin sudo cp pintos-set-cmdline /usr/bin sudo cp Pintos.pm /usr/bin cd ../misc sudo cp gdb-macros /usr/bin 安装 pintos-gdb #  首先编辑 /usr/bin/pintos-gdb 文件，将其中的常量 GDBMACROS 改为放置 gdb-macros 副本的路径（即：/usr/bin/gdb-macros）\nsudo vi /usr/bin/pintos-gdb # Modify the 4th line: GDBMACROS=/usr/bin/gdb-macros 然后设置脚本的执行权限\ncd /usr/bin/ sudo chmod a+rx backtrace sudo chmod a+rx pintos* sudo chmod a+rx gdb-macros sudo chmod a+rx Pintos.pm test pintos-gdb # 如果未提示缺少 gdb-macros 则安装成功 编译 utils #  修改 Makefile 文件，将第 5 行的 LDFLAGS 修改为 LDLIBS\ncd ~/pintos/src/utils vi Makefile # Modify the 5th line: LDFLAGS -\u0026gt; LDLIBS make 命令编译，并将支持文件导入 /usr/bin\nmake sudo cp squish-pty /usr/bin sudo cp squish-unix /usr/bin sudo chmod a+rx /usr/bin/squish* 安装并运行 #  执行如下命令：\ncd ~/pintos/src/threads make cd build chmod +x ../../utils/pintos # 可能需要赋可执行权限 ../../utils/pintos -- run alarm-multiple 即可看到 Pintos 的运行界面，含以下输出：\nUse of literal control characters in variable names is deprecated at ../../utils/pintos line 911. Prototype mismatch: sub main::SIGVTALRM () vs none at ../../utils/pintos line 935. Constant subroutine SIGVTALRM redefined at ../../utils/pintos line 927. squish-pty bochs -q ======================================================================== Bochs x86 Emulator 2.6.7 Built from SVN snapshot on November 2, 2014 Compiled on Sep 28 2021 at 01:44:48 ======================================================================== 00000000000i[ ] reading configuration from bochsrc.txt 00000000000e[ ] bochsrc.txt:8: \u0026#39;user_shortcut\u0026#39; will be replaced by new \u0026#39;keyboard\u0026#39; option. 00000000000i[ ] installing x module as the Bochs GUI 00000000000i[ ] using log file bochsout.txt PiLo hda1 Loading........... Kernel command line: run alarm-multiple Pintos booting with 4,096 kB RAM... 383 pages available in kernel pool. 383 pages available in user pool. Calibrating timer... 204,600 loops/s. Boot complete. Executing \u0026#39;alarm-multiple\u0026#39;: (alarm-multiple) begin (alarm-multiple) Creating 5 threads to sleep 7 times each. (alarm-multiple) Thread 0 sleeps 10 ticks each time, (alarm-multiple) thread 1 sleeps 20 ticks each time, and so on. (alarm-multiple) If successful, product of iteration count and (alarm-multiple) sleep duration will appear in nondescending order. (alarm-multiple) thread 0: duration=10, iteration=1, product=10 (alarm-multiple) thread 0: duration=10, iteration=2, product=20 (alarm-multiple) thread 1: duration=20, iteration=1, product=20 (alarm-multiple) thread 2: duration=30, iteration=1, product=30 (alarm-multiple) thread 0: duration=10, iteration=3, product=30 (alarm-multiple) thread 0: duration=10, iteration=4, product=40 (alarm-multiple) thread 1: duration=20, iteration=2, product=40 (alarm-multiple) thread 3: duration=40, iteration=1, product=40 (alarm-multiple) thread 4: duration=50, iteration=1, product=50 (alarm-multiple) thread 0: duration=10, iteration=5, product=50 (alarm-multiple) thread 1: duration=20, iteration=3, product=60 (alarm-multiple) thread 2: duration=30, iteration=2, product=60 (alarm-multiple) thread 0: duration=10, iteration=6, product=60 (alarm-multiple) thread 0: duration=10, iteration=7, product=70 (alarm-multiple) thread 1: duration=20, iteration=4, product=80 (alarm-multiple) thread 3: duration=40, iteration=2, product=80 (alarm-multiple) thread 2: duration=30, iteration=3, product=90 (alarm-multiple) thread 4: duration=50, iteration=2, product=100 (alarm-multiple) thread 1: duration=20, iteration=5, product=100 (alarm-multiple) thread 1: duration=20, iteration=6, product=120 (alarm-multiple) thread 2: duration=30, iteration=4, product=120 (alarm-multiple) thread 3: duration=40, iteration=3, product=120 (alarm-multiple) thread 1: duration=20, iteration=7, product=140 (alarm-multiple) thread 4: duration=50, iteration=3, product=150 (alarm-multiple) thread 2: duration=30, iteration=5, product=150 (alarm-multiple) thread 3: duration=40, iteration=4, product=160 (alarm-multiple) thread 2: duration=30, iteration=6, product=180 (alarm-multiple) thread 3: duration=40, iteration=5, product=200 (alarm-multiple) thread 4: duration=50, iteration=4, product=200 (alarm-multiple) thread 2: duration=30, iteration=7, product=210 (alarm-multiple) thread 3: duration=40, iteration=6, product=240 (alarm-multiple) thread 4: duration=50, iteration=5, product=250 (alarm-multiple) thread 3: duration=40, iteration=7, product=280 (alarm-multiple) thread 4: duration=50, iteration=6, product=300 (alarm-multiple) thread 4: duration=50, iteration=7, product=350 (alarm-multiple) end Execution of \u0026#39;alarm-multiple\u0026#39; complete. "},{"id":3,"href":"/os-labs/docs/table-of-contents/p1/","title":"Project 1","section":"Table of Contents","content":"Project 1: Threads #  需要提交代码和文档。代码即为包含了 pintos/src 的源代码，文档则是在本网站 Resources 区“实验文档模板”和“Project 1 DesignDoc 模板”的整合版本，云平台上可下载。请将其整合导出为一个 PDF 文件，命名为 p1-组长学号-组长姓名.pdf ，并与代码文件打包为 Zip，提交至云平台。\n提交的目录结构为：\np1-组长学号-组长姓名 ├── pintos ├── src ...... ├── p1-组长学号-组长姓名.pdf 本次实验的 DDL 是 2021 年 11 月 11 日晚 23 时。\n实验背景知识 #  Pintos 简介 #  Pintos 是一个小型的操作系统，其运行在 x86 硬件模拟器 bochs 之上。其已经实现了一个功能较少的操作系统，我们要做的事情就是给这个操作系统添加功能。\n Pintos 结构图如上所示。和市面上常见的操作系统类似，Pintos 将整个体系分为了用户态和内核态，用户态的程序通过系统调用获得内核的服务。其操作系统内核主要分为进程管理、内存管理、文件系统、设备驱动程序等四个部分。本次实验所涉及到的主要是进程管理的部分，同学们需要根据需求实现特定的进程调度方案。\nPintos 目录结构 #  本节将主要给大家介绍 Pintos 中比较重要的几个文件夹。\n在整个 Pintos 实验课中，我们要修改的代码都在 src 目录下。Project 1 的实验中，我们所要修改的文件主要集中在 src/threads 和 src/devices 这两个目录中，由于具体实现方式不同，有的同学也会有可能修改到少量其他目录中的文件。\n. ├── devices # 包含一些与硬件交互的内容 ├── examples # 包含 Pintos 对一些常用 Shell 命令的实现 ├── filesys # 包含 Pintos 中对文件系统的实现 ├── lib # 包含 C 语言中的一些标准库 ├── LICENSE ├── Make.config ├── Makefile ├── Makefile.build ├── Makefile.kernel ├── Makefile.userprog ├── misc ├── tests # 包含各实验的测试文件 ├── threads # 包含 Pintos 对于内核线程的实现 ├── userprog # 包含 Pintos 对于用户线程的实现 ├── utils └── vm 10 directories, 6 files 实验运行方式 #  在实验正式开始前，请同学们修改文件 pintos/src/tests/Make.tests 中的第 55 行\nTESTCMD = pintos -v -k -T $(TIMEOUT) # 修改前 TESTCMD = pintos -k -T $(TIMEOUT) # 修改后 否则，在某些同学的电脑上可能测试无法正常进行。\n修改完毕后，在 Project 1 实验中，代码的运行方式为：\n 进入 src/threads 目录 使用 make clean 命令清除上次编译后的信息 使用 make check 命令对文件进行编译并运行，首次运行会得到如图所示的过点信息：  pass tests/threads/alarm-single pass tests/threads/alarm-multiple FAIL tests/threads/alarm-simultaneous FAIL tests/threads/alarm-priority pass tests/threads/alarm-zero pass tests/threads/alarm-negative FAIL tests/threads/priority-change FAIL tests/threads/priority-donate-one FAIL tests/threads/priority-donate-multiple FAIL tests/threads/priority-donate-multiple2 FAIL tests/threads/priority-donate-nest FAIL tests/threads/priority-donate-sema FAIL tests/threads/priority-donate-lower FAIL tests/threads/priority-fifo FAIL tests/threads/priority-preempt FAIL tests/threads/priority-sema FAIL tests/threads/priority-condvar FAIL tests/threads/priority-donate-chain FAIL tests/threads/mlfqs-load-1 FAIL tests/threads/mlfqs-load-60 FAIL tests/threads/mlfqs-load-avg FAIL tests/threads/mlfqs-recent-1 pass tests/threads/mlfqs-fair-2 pass tests/threads/mlfqs-fair-20 FAIL tests/threads/mlfqs-nice-2 FAIL tests/threads/mlfqs-nice-10 FAIL tests/threads/mlfqs-block 21 of 27 tests failed. 常用文件介绍 #   在 src/tests/threads 文件夹中，包含了实验一的所有测试文件。 make check 之后，src/threads 中会生成一个 build 文件，文件夹 src/threads/build/tests/threads 中包含了程序在每一个测试点的输出。  实验介绍 #  本次实验一共有三个小任务，本文档将依次对它们进行介绍。 实验一文档中有更加详细的介绍，同学们做实验过程中有任何疑问都可以自行查阅官方文档。\n任务一：唤醒时钟 #  这个是本次实验中最为简单的一个任务。在原始的代码实现中，timer_sleep() 函数的实现如下：\nvoid timer_sleep (int64_t ticks) { int64_t start = timer_ticks (); ASSERT (intr_get_level () == INTR_ON); while (timer_elapsed (start) \u0026lt; ticks) thread_yield (); } 由代码最后两行，在原本的代码实现中，timer_sleep() 函数实现的是一个“忙等待”，当线程在调用 timer_sleep() 函数之后，会睡眠 ticks 个单位时间。\n根据题意，我们所要做的事便是消除这种忙等待。根据这个要求，可以想到使用时钟中断。在 thread.h 文件中，可以看到，Pintos 线程一共有以下几个状态：\nenum thread_status { THREAD_RUNNING, /* 运行态。 */ THREAD_READY, /* 就绪态。 */ THREAD_BLOCKED, /* 阻塞态。 */ THREAD_DYING /* 销毁态。 */ }; 因此，线程睡眠时，我们可以将其设置为阻塞态。而睡眠时间结束之后，将其设置为就绪态即可。\n在第一个小实验中，涉及到的测试点一共有以下几个：\n   测试点名称 测试内容     alarm-single 测试单个线程能否在规定时间后被唤醒   alarm-multiple 测试多个线程能否在规定之间后被唤醒   alarm-simultaneous 创建多个线程，并且在同一个时间进入睡眠状态，每个线程的睡眠时长不同，测试唤醒顺序是否正确。   alarm-zero 测试睡眠时长为 0 的情况   alarm-negative 测试睡眠时长为负数的情况    注意点：\n需要考虑到睡眠时长为 0 或者负数的情况\n任务二：优先级调度 #  这是本次实验最难的任务，主要包含以下两大部分：实现优先级调度和实现优先级捐赠。\n实现优先级调度 #  优先级调度概念：\n在原始的代码实现中，线程的就绪队列基本采用的是先来先服务（FCFS）的调度方式，即先进入就绪队列的线程在调度时会先获得 CPU，这个实验的目的是将这种调度策略改成优先级调度。即当一个线程被添加到就绪列表中，并且该线程的优先级高于当前正在运行的线程时，当前线程应该立即将处理器交付给新线程。类似地，当有多个线程正在等待锁、信号量或条件变量时，优先级最高的等待线程应该首先被唤醒。\n在 Pintos 中，线程优先级范围为 0 到 63。 较低的数字对应较低的优先级，因此优先级 0 是最低优先级，优先级 63 是最高优先级。 线程创建时默认的优先级为 PRI_DEFAULT = 31。\n在这一部分涉及的代码测试点主要有：\n   测试点名称 测试内容     alarm-priority 创建不同优先级的线程，看他们唤醒之后的调度是否符合优先级顺序。   priority-change 降低线程的优先级，观察设置之后优先级比它高的线程是否被立刻调度。   priority-sema 测试信号量唤醒时，是否会唤醒信号量等待队列中优先级最高的线程。   priority-condvar 测试条件变量唤醒时，是否会唤醒条件变量等待队列中优先级最高的线程。    注意点：\n在实现优先级调度的时候，不仅仅需要考虑线程的就绪队列，还要考虑信号量和条件变量的等待队列。\n实现优先级捐赠 #  优先级捐赠概念：\n在本实验中，优先级捐赠主要是针对线程对于锁的获取的。例如：如果线程 H 拥有较高的优先级，线程 M 拥有中等的优先级，线程 L 拥有较低的优先级。此时若线程 H 正在等待 L 持有的锁, 且 M 一直在就绪队列之中，那么线程 H 将永远无法获得 CPU。因此，这个时候需要将 H 的优先级捐赠给 L。\nH M L | ^ | | └------------------ 申请锁 注意点：\n 一个锁只能被单个线程持有，而一个线程却可以持有多个锁。当线程持有多个锁时，需要将线程的优先级设置为其被捐赠的优先级中最大的。 会出现递归捐赠的问题。例如当前存在一个高优先级线程 H，一个中优先级线程 M，一个低优先级线程 L。如果 H 正在申请 M 持有的锁，M 正在申请 L 持有的锁，那么 M 和 L 的优先级都需要被设置为 H 的优先级。  等待锁 等待锁 H -\u0026gt; M -\u0026gt; L 以下是这部分内容所涉及的测试点：\n   测试点名称 测试内容     priority-donate-one 提出优先级捐赠概念，用一个线程给另一个线程捐赠优先级，利用打印优先级和标答做对比来判断是否通过。   priority-donate-multiple 用两个线程给一个线程捐赠优先级，观察优先级恢复的时候是否符合预期的答案。   priority-donate-multiple2 测试线程在释放锁的瞬间，是否会被高优先级线程抢占。   priority-donate-nest 创建三个线程 A、B、C，先让 B 给 A 捐赠优先级，再让 C 给 B 捐赠优先级，观察 A 的优先级是否有改变。   priority-donate-sema 锁 + 优先级捐赠 + 信号量混合，之后说明测试过程。   priority-donate-lower 在优先级捐赠生效的情况下降低线程的优先级，希望是线程的优先级没有被改变，并在释放锁之后恢复到刚刚设置的优先级。    任务三：高级调度 #  在优先级调度策略之中，高优先级的进程永远抢占着 CPU，而低优先级线程能获得的时间非常少。在本实验中，我们会实现更加复杂的调度器，该实验所实现的调度器会自动维护线程的优先级。同样的，在任何给定的时间，调度程序从最高优先级的非空队列中选择一个线程。本实验需要弄清楚以下几个概念：\n ready_threads：代表当前正在处于运行态和就绪态的线程的数量。 load_avg：代表对过去一秒钟内准备运行的线程的数量的估计，其初始值被设置为 0，每一秒（100 个 ticks），load_avg 会按照以下公式进行更新：load_avg = 59/60 * load_avg + 1/60 * ready_threads。 recent_cpu：每一个线程都拥有的变量，反应该线程获得 cpu 的多少。每一个 ticks，正在运行的线程的 recent_cpu 会增加 1。每一秒(100 个 ticks)，所有的线程的 recent_cpu 会按照以下公式进行更新：recent_cpu = (2 * load_avg) / (2 * load_avg + 1) * recent_cpu + nice。 nice：代表线程对其他线程的友好程度，取值范围为 0 到 20，nice 值为 0 不会影响该线程的优先级，nice 值越大，该线程对其他线程越友好，即该线程的优先级越低，线程创建时初始 nice 值为 0。 priority：线程的优先级，每四个 ticks，线程的优先级应当按照以下公式进行更新：priority = PRI_MAX - 1/4 * recent_cpu - 2 * nice。  注意点：\n 在 Pintos 中，存在一个 thread_mlfqs 的布尔量控制高级调度，当其值为 true 时，使用高级调度，当值为 false 时，使用优先级调度。高级调度和优先级调度存在少部分冲突，需要特殊判断。 如果前两个任务实现的时间复杂度过高，会影响该任务的测试。 使用公式计算的优先级可能超出 Pintos 设定的优先级范围(0-63) 在本实验之前请各位确保已经阅读 任务三详细文档，本实验中涉及到浮点运算的部分都需要使用该文档中所提及到的方法。  任务三的测试样例如下：\n   测试点名称 测试内容     mlfqs-load-1 加载 1 个线程（主线程），运行一段时间后睡眠，检查 load_avg 有没有算对。   mlfqs-load-60 加载 60 个线程，同上，检查 load_avg 有没有算对。   mlfqs-load-avg 加载 60 个线程，并有一次唤醒和睡眠的行为，检查 load_avg 有没有算对。   mlfqs-recent-1 加载 1 个线程（主线程），睡眠一段时间后唤醒，检查 recent_cpu 有没有算对。   mlfqs-fair-2 运行 2 个nice = 0的线程，检查他们间运行时间的差距。   mlfqs-fair-20 运行 20 个nice = 0 的线程，检查他们间运行时间的差距。   mlfqs-nice-2 运行 1 个nice = 0和 1 个nice = 5的线程，共运行 3000 时间，检查他们的运行时长。   mlfqs-nice-10 运行 10 个nice为 0 ~ 9 的线程，共运行 3000 时间，检查他们的运行时长。   mlfqs-block 检查在 mlfqs 模式下优先级捐赠会不会改变线程优先级等级，正常下不改变。    "},{"id":4,"href":"/os-labs/docs/table-of-contents/p2/","title":"Project 2","section":"Table of Contents","content":"Project 2: User Programs #  实验环境配置和运行 #  实验开始之前，同学们需要检查 src/userprog/Make.vars 中最后一行代码，看看其调用的是否是 bochs，需要将其改为：SIMULATOR = --bochs 。（如本就是使用的是 qemu 则不用改）\n建议用一个空白的 Pintos 系统来实现，以防止 Project 1 对 Project 2 的影响。\n本次实验建议使用 huahuaxiaomuzhu 开发的 debug-my-pintos 工具。可在 VS Code 里可视化设置断点并调试。\n实验的意义探究 #  我们知道，Pintos 实验旨在通过补充代码，实现一个小型的操作系统。那么这个操作系统，到底是什么级别的系统呢？\n这个需要从 Intel 公司的 80x86 系列处理器说起。通过之前计组和系统编程已经学习到的知识，大家应该都知道 8086 处理器是一个 16 位处理器，系统总线 20 根，可寻址最大内存空间达 1MB，范围是 00000H-FFFFFH，但其内部的寄存器和 ALU 都只有 16 位，所以在寻址时，需要将段地址乘以 16，再加上偏移地址，以此来实现 20 位的寻址。这都是后话，最主要的是，在 8086 时代，用户可以直接寻址到内存空间的任何位置，这就有可能导致用户错误地修改某些地址值，导致系统崩溃。\n由于技术的进步以及人们对多用户操作同一台电脑的需求，在 80386 时代，终于将系统的工作方式给分离了，80386 具有实模式、保护模式和 v68 模式这三种工作模式。其中，实模式其实算是 8086 体系的延续，在该模式下的寻址方式和 8086 无异，这个模式也是为了兼容 16 位体系下的程序。而用户一般所处的状态就是保护模式，在这个模式下可以使用 386 系统的 32 根主线，寻址模式发生根本性的变化，最主要的是引入了特权级的概念，由于我们知道在 8086 时代，随意的内存修改可能导致系统崩溃，而想要避免这种崩溃，就需要把系统内核给保护起来，为此，386 有个 4 个特权级 r0-3，我们的系统内核在最高级别 r0 中，特权级所处的内存空间分置，允许高特权级访问低特权级内存空间，而不允许反向地访问。那么这样一来，确实避免了随意对内存空间的修改，可又引出了一些新的问题，比如系统对外设端口的调用，是通过中断的方式进行的；比如创建新的进程等，这些函数都被内核给把持着，当一个用户想要手动开启这些功能的时候，就遇到了无法访问的问题，这个时候，就需要让低特权级向高特权级发起一个建议，这个建议我们把他叫做系统调用，使用系统调用，就可以让用户在低特权级下使用高特权级的功能。\n而这，就是我们第二次实验所要完成的事情。\n实验思路讲解 #  在本次实验的主线是实现 13 个系统调用，我们可以大致将这 13 个系统调用分为两部分：与进程有关的（exec, wait, exit）系统调用和其他系统调用。\n与进程相关的系统调用实现会略为复杂：\n exec 中需要我们实现参数的分离与传递 wait 中需要我们实现进程之间的等待，并能够处理异常输入 exit 中需要我们能够完整的回收进程所使用的资源。  其中，exec 单独作为 任务1 参数分离出现，任务2 则是要完成全部 13 个系统调用\n对于栈区的理解 -\u0026gt; 拓展阅读\nPintOS 中使用了与 8086处理器 相同的函数调用规则：\n  调用者需要先将函数所需的参数按照从右到左的顺序依次入栈（堆栈是向下增长的，用 C 语言的形式来描述，每一次入栈操作都形同于 *--sp = value）\n  调用者使用 call 指令完成如下两件事：\n  将调用者的下一条指令地址入栈 （return address）\n  将指令寄存器指向被调用者的第一条指令\n    被调用者执行时，栈寄存器指向的是 return address。\n  如果被调用者有返回值，将会存至寄存器 eax 中\n  返回时，被调用者使用 ret 指令完成如下两件事：\n  将返回地址出栈\n  将指令寄存器指向刚出栈的地址。\n    返回后，调用者将参数依次从栈中弹出，继续运行。\n  在实验过程中，我们将在两个地方考察对栈的理解：\n 系统调用本身也可以理解为一次函数调用，我们需要通过栈寄存器 esp 获得系统调用的参数 在系统调用 exec 中，PintOS 将通过模拟 ret 指令来运行用户程序并给用户程序传递参数，为此，我们需要在返回之前，将栈区模拟为即将返回的状态（即当前的栈寄存器指向 return address，其上包含用户程序的全部参数。）  评测的一些细节\n在评测的过程中，实际上是运行了一个用户程序(userprog)，并通过用户程序的输出来判断测试点是否通过。因此，在实现 exec , write 等系统调用之前，是无法正常评测的。\n为了能够帮助大家更快的上手 Project2 ，这里提供一个实现参考顺序：\n  在 setup_stack() 函数中，令 *esp = PHYS_BASE - 12  ，这一步实际上是放弃了参数的传递（减去的 12 其实分别对应 argv , argc ，return address ），这样可以让我们的 OS 能够执行不含参数的测试点。\n  搭建系统调用的框架并实现 exit 和 write 调用，让用户程序可以正常的输出字符串并退出。随后，在 process_wait 中额外增加一句 sleep 确保会在子线程执行结束后返回（正确的实现方式是在子线程结束后立即返回，这里为了确保子线程结束，请把 sleep 等待的时间写的稍微长一点）\n 其实只要实现 fd=1 时的 write 函数就已经可以让用户程序输出了。在这里可以选择只实现这一部分的 write，完整版的 write 在写完参数传递后在接着完成。\n   前置任务：打印进程退出信息 #  Pintos 要求每一次退出时都打印退出代码，没有这个打印行为，几乎所有的点都无法通过，但其本身没有点。首先我们需要在 threads/thread.h 函数中修改 thread 结构体，为其添加退出码这个值，其次我们在系统调用 exit 时，需要将退出码存储在结构体中，最后在 userprog/process.c 中 process_exit() 函数中按文档所给的格式（见 3.3.2）打印退出码。（这里需要解释一点，Pintos 实验做到这里时，仍没有区分线程和进程的概念，一定程度上可以混用）。\n任务 1：参数分离 #     序号 名称 测试点     1 args-none 命令没有任何的参数，检查第 0 个参数是不是文件名，运行命令为 args-none。   2 args-single 有一个参数，检查参数数量和内容是否正确，运行命令为 args-single onearg。   3 args-multiple 一共有 4 个参数，运行命令为 args-multiple some arguments for you!。   4 args-many 一共有 22 各参数，运行命令为 args-many a b c d e f g h i j k l m n o p q r s t u v。   5 args-dbl-space 有参数用两个空格间隔，确保要识别正确，运行命令为 args-dbl-space two spaces!。不需要特别在意这个。    上表是该任务对应的点以及分别在考察什么。\n第一个任务，实际上较为复杂，我们需要观察进程的创建过程，在 process.c 的 process_execute 即为我们的线程创建函数。其中 file_name 就是我们传递进来的参数，但是它不仅包含了我们要执行的函数，也包括了后面的参数，所以这里需要进行字符串分割。幸运的是，Pintos 已经为我们提供了一个字符串分割的函数，声明在 lib/string.h 中。\n分割完参数后，可以看到进程拉起了一个线程，我们需要在线程的创建函数中 start_process 中，将参数放置于 esp 的对应位置。堆栈结构请参照 3.5.1。\n   Address Name Data Type     0xbffffffc argv[3][...] \u0026quot;bar\\0\u0026quot; char[4]   0xbffffff8 argv[2][...] \u0026quot;foo\\0\u0026quot;  char[4]   0xbffffff5 argv[1][...] \u0026quot;-1\\0\u0026quot;  char[3]   0xbfffffed argv[0][...] \u0026quot;/bin/ls\\0\u0026quot;  char[8]   0xbfffffec word-align 0 uint8_t   0xbfffffe8 argv[4] 0 char *   0xbfffffe4 argv[3] 0xbffffffc char *   0xbfffffe0 argv[2] 0xbffffff8 char *   0xbfffffdc argv[1] 0xbffffff5 char *   0xbfffffd8 argv[0] 0xbfffffed char *   0xbfffffd4 argv 0xbfffffd8 char **   0xbfffffd0 argc 4 int   0xbfffffcc return address 0 void (*)()    同学们可参照压栈图，将分割出的参数压栈到中断现场的合适位置。\n任务 2：系统调用 #  调用参数所处内存地址 #     序号 名称 测试点     6 sc-bad-sp 将 esp 指向非法的地方之后触发系统调用，正常情况下应该 exit(-1)。测试用例是利用内联汇编来实现的。   7 sc-bad-arg 将 esp 指向了栈顶下 4 字节（刚好放进了 exit 的系统调用号），试图在获取系统调用的参数时访问非法的内存区域，正常情况下应该以 exit(-1) 退出。   8 sc-boundary 让 exit 的系统调用号和参数正好放在页边界，观察退出状态值是否正常。不需要特别在意这个。   9 sc-boundary-2 让 exit 的参数的前三个字节和最后一个字节存放在页边界，观察退出状态值是否正常。不需要特别在意这个。    该任务的目的是，检查我们传递的参数的内存地址，正如我们在实验目的里阐述的，使用特权级的目的是保护内存，这里也是一样，Pintos 将 kernel 和用户内存空间分成了两部分，如下图所示，BASE 以上是内存空间，08048000-BASE 之间，才是用户进程空间，如果一个指针，指向了没有权限的位置，就应该直接以 -1 退出。文档的 3.1.5 部分给我们提供了两种思路，一种是 userprog/pagedir.c 和在 threads/vaddr.h 中的相关函数 pagedir_get_page，来验证地址范围，一种是通过访问该地址，来造成 page_fault，在 page_fault 处理函数中，再退出。\nPHYS_BASE +----------------------------------+ | user stack | | | | | | | | V | | grows downward | | | | | | | | | | grows upward | | ^ | | | | | | | +----------------------------------+ | uninitialized data segment (BSS) | +----------------------------------+ | initialized data segment | +----------------------------------+ | code segment | 0x08048000 +----------------------------------+ | | | | | | | | | | 0 +----------------------------------+ Tip 2：\n这里一定要记得，参数的地址不一定是连续的，而且每个参数的地址都是 4 个 byte，注意有可能一个参数地址一半跨越界限，一半不跨越的情况。\n打开关闭文件 #     序号 名称 测试点     19 open-normal 正常打开一个文件，如果 fd\u0026gt;2 则 pass。   20 open-missing 打开不存在的文件，fd 应为 -1。   21 open-empty 文件名为空字符串，fd 应为 -1。   22 open-boundary 文件名跨页，看是否能正常打开。不需要特别在意这个。   23 open-null 文件名使用 NULL，应该以 exit(-1) 退出。   24 open-bad-ptr 文件名指针处于用户空间，但是指向了未分配的区域，应该以 exit(-1) 退出。   25 open-twice 打开同一个文件两次，观察是否能正常打开且 fd 是不是不一样（要求不一样）。   26 close-normal 正常关闭一个文件，看程序是否正常退出。   27 close-twice 关闭两次同一个 fd，正常退出或者以 -1 退出都可以。   28 close-stdin 关闭标准输入流，正常退出或者以 -1 退出都可以。   29 close-stdout 关闭标准输出流，正常退出或者以 -1 退出都可以。   30 close-bad-fd 关闭不存在的 fd，正常退出或者以 -1 退出都可以。    这一块是过点的集中地，很容易写完后过许多点，收获做实验的满足感。\n相信做过 Project 1 的同学们对 Pintos 中的链表结构都不陌生了，我们可以使用链表（如果愿意的话你也可以使用数组）来维护打开的文件列表，同时按我们已有的知识，，每一个打开的文件都需要有一个文件描述符 fd，且 fd 在不同进程中不共享，所以可见是由进程维护描述符，同时，0，1，2 三个描述符已经默认分配，所以我们必须从 3 开始为新打开的文件分配描述符。\nTip 3：\n实验过点的文件不会打开很多，所以不需要考虑关闭文件后，描述符的重新利用。\n同理，打开一个文件需要文件地址，这个地址，也是需要我们进行地址判断，防止其越界。到了这里，我们就可以使用 filesys/filesys.c 中定义的 filesys_open 来完成 open 的系统调用了。同时也要在进程中维护打开的文件列表。\n关闭也是同理，我们需要将维护的文件及其描述符从进程的文件列表中移除，并使用 file_close 关闭该文件。\nTip 4：\n在维护打开文件元素时，使用了 malloc 的话，记得一定要在关闭时释放，这一点对于后面的某个点至关重要。同时注意，在一个进程退出时，也应该关闭其打开的所有文件。\n创建移除文件 #     序号 名称 测试点     12 create-normal 正常创建一个文件，然后用 open 系统调用看是否能打开。   13 create-empty 创建文件名为空的文件，返回创建失败或直接以 -1 退出。   14 create-null 创建的文件名为 NULL，要求以 -1 退出。   15 create-bad-ptr 创建的文件名指向未分配空间，返回创建失败或直接以 -1 退出。   16 create-long 创建一个文件名很长的文件。不用特别在意他。   17 create-exists 创建重名的文件，返回创建失败即可。   18 create-bound 创建的文件名跨页。不用特别在意他。    这一部分较为简单，创建文件调用 filesys/filesys.c 中定义的 filesys_create 即可，移除调用 filesys/filesys.c 中定义的 filesys_remove。\n读写文件 #     序号 名称 测试点     31 read-normal 正常读取文件，比对读取的内容是否正确。   32 read-bad-ptr 存放读取内容的 buffer 指向了没被映射的地址，返回 0 或者以 -1 退出都可以。   33 read-boundary buffer 跨页，不需要特别在意他。   34 read-zero 读取 size = 0 的内容。   35 read-stdout 试图读取标准输出流，返回 0 或者以 -1 退出都可以。   36 read-bad-fd 读取不存在的 fd，返回 0 或者以 -1 退出都可以。   37 write-normal 正常写入文件，判断返回值是否正确。   38 write-bad-ptr 写入读取内容的 buffer 指向了没被映射的地址，返回 0 或者以 -1 退出都可以。   39 write-boundary buffer 跨页，不需要特别在意他。   40 write-zero 写入 0 byte 的内容。   41 write-stdin 试图写入标准输入流，返回 0 或者以 -1 退出都可以。   42 write-bad-fd 写入不存在的 fd，返回 0 或者以 -1 退出都可以。    和创建移除一样，比较简单，参照 3.3.4 的参数格式，同时对于 write，我们已经实现了向终端写入。read 会用到 input_getc()与 file_read()，write 会用到 file_write()与 putbuf()。\nTip 5：\n这里除了注意参数是否和法外，还需要判断缓冲区是否合法。\n执行与等待 #     序号 名称 测试点     43 exec-once 创建一个子进程，观察子进程退出代码（81），以及父进程退出代码是否正确（0）。   44 exec-arg 执行的子进程有多个参数，观察参数是否正确。   45 exec-multiple wait(exec(…))五次，观察退出代码以及退出顺序。   46 exec-missing 执行不存在的文件，观察 exec 返回值（-1）。   47 exec-bad-ptr 执行的命令指向未被分配的内存区域，返回 0 或者以 -1 退出都可以。   48 wait-simple wait 一个子进程，观察返回值是否和子进程的退出代码一致（81）。   49 wait-twice 等待两次同一个子进程，第二次等待应该返回 -1。   50 wait-killed 等待一个子进程，子进程刚执行就被 kill 杀死（应该以 -1 退出），观察子进程退出代码以及父进程在 wait 后的返回值。   51 wait-bad-pid wait 一个不存在的 PID。    该部分为创建子进程和父进程等待子进程并回收，也是一个难点。\n这里我们还需要提到前面讲过的一点，Pintos 在这里还没有特别区分进程和线程的概念，可以理解为一个线程就是一个进程，所以其 ID 可以一一映射。该部分的重点在于父进程需要维护创建的子进程列表。子进程的创建过程其实就是我们前面修改过的 process_execute() 函数。注意到在该函数的 thread_create 函数执行后，其实子进程就已经转移到 start_process 中开始运行或者加入就绪队列了。这里我们要保证子进程一定成功创建，就需要实现一个同步锁，来保证子进程 load 成功才接着执行父进程，子进程一旦创建失败，说明该该调用失败了。\n而对于 wait 操作，很明显也需要一个锁，保证父进程在子进程执行期间无法进行任何操作，等待子进程退出后，父进程获取子进程退出码，并回收资源。这里的锁的设计非常精妙，要保证父进程 wait 时，无法执行任何操作，子进程退出时，需要立刻通知父进程，但不能直接销毁，而要等待父进程来回收资源获取返回码等，然后才可以正常销毁。需要几个锁来完成这个操作，同学们可以好好考虑。\nmulti #     序号 名称 测试点     52 multi-recurse 递归创建子进程，共 16 个，观察进入和退出的顺序。   53 multi-child-fd 子进程尝试关闭一个父进程打开的文件（应该要失败），之后看父进程还能不能正常访问这个文件。    这一部分几乎没有需要多写的，只需要完成 filesize 这个系统调用。\nfilesize 在文档中的声明为：int filesize (int fd);\n所以需要我们用 fd 去寻找打开的文件。实现时调用 file_length 就行。\nrox #     序号 名称 测试点     54 rox-simple 尝试改写自己的可执行文件（write 应该要返回 0）。   55 rox-child 父进程先写好子进程的可执行文件，然后执行子进程。接下来子进程尝试改写自己的可执行文件（write 应该要返回 0），之后会退出。然后父进程再次改写子进程的可执行文件（应该要成功）。   56 rox-multichild 父进程先写好子进程的可执行文件，然后递归地创建 5 个子进程且他们都试图改写自己的可执行文件；然后递归地退出，退出前也试图改写自己的可执行文件；最后一次父进程会再次改写子进程的可执行文件（这次应该要成功）。    这一部分旨在防止进程修改正在运行的可执行文件，详见文档中的 3.3.5\n可执行文件在 Pintos 中的定义为用来创建进程的文件，即创建进程时打开的那一个文件。filesys/file.c 文件中定义了函数 file_deny_write()，该函数可以禁止对文件的写操作。我们需要在 load 时，禁止对该文件的写操作，在退出时回复。\n同时这一块需要实现 seek 调用。需要用到 file_seek() 函数。\nbad #     序号 名称 测试点     57 bad-read 读取 NULL 指针的内容。   58 bad-write 给 NULL 指针的位置赋值。   59 bad-read2 读取内核空间的内容。   60 bad-write2 往内核空间赋值。   61 bad-jump 把 NULL 伪装成函数后调用。   62 bad-jump2 把内核空间地址伪装成函数后调用。    这一部分，理论上要是做到了前面的每个地址访问都验证地址合法性，是可以直接通过的。如果有不通过，除了补充前面的不足外，由于访问非法地址会引起 page_fault，所以我们可以在 exception.c 中对 page_fault()进行修改，在 kill 时结束进程，返回 -1.\n资源释放 #     序号 名称 测试点     63 multi-oom 全实验最难的一个点，但也有可能是最简单的一个点。    该部分旨在探究同学们编码过程中，对于资源的合理理由，务必要做到每一个资源申请后，都会有释放。包括前面提到的文件的退出，消除开辟的内存空间，同时注意到进程退出时，关闭所有打开的文件，以及 open、close、create、remove、execute、wait 等所有过程中开辟的空间都需要关闭。\n正常分支流（新进程会从 2 开始）：\n 创建第 0 号进程（根进程），参数为 RECURSE 如果进程的参数是 CRASH，跳转到崩溃分支流执行 如果进程号是 0，执行 10 次以下的操作，否则只执行 1 次以下的操作：  如果进程号大于 15，创建 n+1 号进程，参数为 CRASH 验证子进程返回值是否为 -1 创建 n+1 号进程，参数为 RECURSE，如果创建失败则返回 n（此处失败是因为资源不够了），否则等待子进程返回值 比对每次子进程的返回值，观察是否都相同（不相同则会 FAIL）   疯狂打开文件直到不能打开或打开超过了 126 个文件 如果是 0 号进程，验证下递归打开的进程层数是不是不小于 30，不是的话报错 返回子进程返回值  崩溃分支流\n 疯狂打开文件指定不能打开或打开超过了 126 个文件 从 bad-write、bad-read、bad-write2、bad-read2、open-bad-ptr 中随机选择一种方式来触发异常然后退出  文件系统 #     序号 名称 测试点     64 lg-create 创建一个大的空白文件，检查文件大小与内容是否是合格的。   65 lg-full 创建一个大的文件，在里面填满内容，检查文件的大小与内容是否和期望的一致。   66 lg-random 创建一个大的文件，往里边多次随机写入内容，然后读取内容比对。   67 lg-seq-block 创建一个大的文件，以 block_size 为单位多次写入内容，然后读取内容进行比对。   68 lg-seq-random 与上一个相比，block_size 变为了随机数。   69 sm-create 创建一个小的空白文件，检查文件大小与内容是否是合格的。   70 sm-full 创建一个小的文件，在里面填满内容，检查文件的大小与内容是否和期望的一致。   71 sm-random 创建一个小的文件，往里边多次随机写入内容，然后读取内容比对。   72 sm-seq-block 创建一个小的文件，以 block_size 为单位多次写入内容，然后读取内容进行比对。   73 sm-seq-random 与上一个相比，block_size 变为了随机数。   74 syn-read 创建 10 个进程，打开同一个文件并一个字节一个字节地比对内容，保证中途没有异常发生（打开文件失败等情况）。   75 syn-remove 打开一个文件后移除文件，确认文件是否仍然可读写。   76 syn-write 比起 syn-read，读变成了写，但只写一次。    其中 74-76 涉及到了文件的锁，我们需要对文件系统设计一个锁，在所有用到的操作中，操作前都上锁，操作后都去除锁，基本上就可以实现。这一部分的修改在 filesys.h 和 filesys.c 中完成。\n"},{"id":5,"href":"/os-labs/docs/resources/doc-template/","title":"实验文档模板","section":"Resources","content":"Project X 实验文档模板 #   Project X (X = 1, 2, 3)\n 团队 #  基本信息 #     姓名 学号 Git 用户名                          每位组员的主要工作内容 #  Git 相关 #   Pintos 的 Git 项目地址\n参考资料 #    资料 1  资料 2  实验要求 #   根据实验指南，简要总结实验要实现什么。\n 需求分析 #   基于实验要求，思考并提出需求。如：要完成实验要求中的A部分，我们要在哪里实现一个什么东西才能满足上述需求。\n 设计思路 #   在需求分析的基础上，可进行更详细的算法上的描述、介绍数据结构等。\n 重难点讲解 #   对于实验过程中的重难点进行讲解，可写踩坑记录、Debug 的解决方案等。\n 用户手册 #   完成实验过程中的一些命令：如何执行/如何调试等。\n 测试报告 #   贴上过点情况的截图，并针对测试点进行分析。如哪几个测试点比较坑，是怎么发现和解决的。\n 各成员的心得体会 #  Student1 #  Student2 #  \u0026hellip;\n其他你认为有必要的内容 (Optional) #  空白 Markdown 模板 #  # Project X 实验文档 ## 团队  ### 基本信息  | 姓名 | 学号 | Git 用户名 | | ---- | ---- | ---------- | | | | | | | | | | | | | | | | | ### 每位组员的主要工作内容  ### Git 相关  [Pintos 的 Git 项目地址]() ### 参考资料  1. []() 2. []() ## 实验要求  ## 需求分析  ## 设计思路  ## 重难点讲解  ## 用户手册  ## 测试报告  ## 各成员的心得体会  ### Student1  ### Student2  ### Student3  ### Student4  ## 其他你认为有必要的内容 (Optional) "},{"id":6,"href":"/os-labs/docs/resources/project01-design-doc/","title":"Project 1 DesignDoc 模板","section":"Resources","content":"Project 1 Design Document #  QUESTION 1: ALARM CLOCK #  DATA STRUCTURES #   A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n ALGORITHMS #   A2: Briefly describe what happens in a call to timer_sleep(), including the effects of the timer interrupt handler.\n  A3: What steps are taken to minimize the amount of time spent in the timer interrupt handler?\n SYNCHRONIZATION #   A4: How are race conditions avoided when multiple threads call timer_sleep() simultaneously?\n  A5: How are race conditions avoided when a timer interrupt occurs during a call to timer_sleep()?\n RATIONALE #   A6: Why did you choose this design? In what ways is it superior to another design you considered?\n QUESTION 2: PRIORITY SCHEDULING #  DATA STRUCTURES #   B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n  B2: Explain the data structure used to track priority donation. Use ASCII art to diagram a nested donation. (Alternately, paste an image.)\n ALGORITHMS #   B3: How do you ensure that the highest priority thread waiting for a lock, semaphore, or condition variable wakes up first?\n  B4: Describe the sequence of events when a call to lock_acquire() causes a priority donation. How is nested donation handled?\n  B5: Describe the sequence of events when lock_release() is called on a lock that a higher-priority thread is waiting for.\n SYNCHRONIZATION #   B6: Describe a potential race in thread_set_priority() and explain how your implementation avoids it. Can you use a lock to avoid this race?\n RATIONALE #   B7: Why did you choose this design? In what ways is it superior to another design you considered?\n QUESTION 3: ADVANCED SCHEDULER #  DATA STRUCTURES #   C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n ALGORITHMS #   C2: Suppose threads A, B, and C have nice values 0, 1, and 2. Each has a recent_cpu value of 0. Fill in the table below showing the scheduling decision and the priority and recent_cpu values for each thread after each given number of timer ticks:\n    timer ticks recent_cpu A recent_cpu B recent_cpu C priority A priority B priority C thread to run     0          4          8          12          16          20          24          28          32          36            C3: Did any ambiguities in the scheduler specification make values in the table uncertain? If so, what rule did you use to resolve them? Does this match the behavior of your scheduler?\n  C4: How is the way you divided the cost of scheduling between code inside and outside interrupt context likely to affect performance?\n RATIONALE #   C5: Briefly critique your design, pointing out advantages and disadvantages in your design choices. If you were to have extra time to work on this part of the project, how might you choose to refine or improve your design?\n 空白模板 #  # Project 1 Design Document ## QUESTION 1: ALARM CLOCK  ### DATA STRUCTURES \u0026gt; A1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less.  ### ALGORITHMS \u0026gt; A2: Briefly describe what happens in a call to timer_sleep(), including the effects of the timer interrupt handler. \u0026gt; A3: What steps are taken to minimize the amount of time spent in the timer interrupt handler?  ### SYNCHRONIZATION \u0026gt; A4: How are race conditions avoided when multiple threads call timer_sleep() simultaneously? \u0026gt; A5: How are race conditions avoided when a timer interrupt occurs during a call to timer_sleep()?  ### RATIONALE \u0026gt; A6: Why did you choose this design? In what ways is it superior to another design you considered?  ## QUESTION 2: PRIORITY SCHEDULING  ### DATA STRUCTURES \u0026gt; B1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less. \u0026gt; B2: Explain the data structure used to track priority donation. Use ASCII art to diagram a nested donation. (Alternately, paste an image.)  ### ALGORITHMS \u0026gt; B3: How do you ensure that the highest priority thread waiting for a lock, semaphore, or condition variable wakes up first? \u0026gt; B4: Describe the sequence of events when a call to lock_acquire() causes a priority donation. How is nested donation handled? \u0026gt; B5: Describe the sequence of events when lock_release() is called on a lock that a higher-priority thread is waiting for.  ### SYNCHRONIZATION \u0026gt; B6: Describe a potential race in thread_set_priority() and explain how your implementation avoids it. Can you use a lock to avoid this race?  ### RATIONALE \u0026gt; B7: Why did you choose this design? In what ways is it superior to another design you considered?  ## QUESTION 3: ADVANCED SCHEDULER  ### DATA STRUCTURES \u0026gt; C1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less.  ### ALGORITHMS \u0026gt; C2: Suppose threads A, B, and C have nice values 0, 1, and 2. Each has a recent_cpu value of 0. Fill in the table below showing the scheduling decision and the priority and recent_cpu values for each thread after each given number of timer ticks:  | timer ticks | `recent_cpu` A | `recent_cpu` B | `recent_cpu` C | `priority` A | `priority` B | `priority` C | thread to run | | ----------- | -------------- | -------------- | -------------- | ------------ | ------------ | ------------ | ------------- | | 0 | | | | | | | | | 4 | | | | | | | | | 8 | | | | | | | | | 12 | | | | | | | | | 16 | | | | | | | | | 20 | | | | | | | | | 24 | | | | | | | | | 28 | | | | | | | | | 32 | | | | | | | | | 36 | | | | | | | | \u0026gt; C3: Did any ambiguities in the scheduler specification make values in the table uncertain? If so, what rule did you use to resolve them? Does this match the behavior of your scheduler? \u0026gt; C4: How is the way you divided the cost of scheduling between code inside and outside interrupt context likely to affect performance?  ### RATIONALE \u0026gt; C5: Briefly critique your design, pointing out advantages and disadvantages in your design choices. If you were to have extra time to work on this part of the project, how might you choose to refine or improve your design? "},{"id":7,"href":"/os-labs/docs/resources/project02-design-doc/","title":"Project 2 DesignDoc 模板","section":"Resources","content":"Project 2 Design Document #  QUESTION 1: ARGUMENT PASSING #  DATA STRUCTURES #   A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n ALGORITHMS #   A2: Briefly describe how you implemented argument parsing. How do you arrange for the elements of argv[] to be in the right order? How do you avoid overflowing the stack page?\nA2: 简要描述你是怎么实现 Argument parsing 的。你是如何安排 argv[]中的 elements，使其在正确的顺序的？你是如何避免 stack page 的溢出的？\n RATIONALE #   A3: Why does Pintos implement strtok_r() but not strtok()?\nA3: 为什么 Pintos 中实现 strtok_r()而不是 strtok()？\n  A4: In Pintos, the kernel separates commands into a executable name and arguments. In Unix-like systems, the shell does this separation. Identify at least two advantages of the Unix approach.\nA4: 在 Pintos 中，kernel 将命令分成了可执行文件的 name 以及参数。在 Unix-like 的系统中，shell 完成这部分的分隔。列举至少 2 种 Unix 这样做的好处。\n QUESTION 2: SYSTEM CALLS #  DATA STRUCTURES #   B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n  B2: Describe how file descriptors are associated with open files. Are file descriptors unique within the entire OS or just within a single process?\nB2: 描述文件描述符是如何与打开文件相联系的。文件描述符是在整个中唯一还是仅在单个进程中唯一？\n ALGORITHMS #   B3: Describe your code for reading and writing user data from the kernel.\nB3: 描述你用来从 kernel 中读写文件的代码。\n  B4: Suppose a system call causes a full page (4,096 bytes) of data to be copied from user space into the kernel. What is the least and the greatest possible number of inspections of the page table (e.g. calls to pagedir_get_page()) that might result? What about for a system call that only copies 2 bytes of data? Is there room for improvement in these numbers, and how much?\nB4: 假设一个系统调用造成一整页的数据(4096 bytes)从用户空间复制到 kernel。\n求可能造成的最小和最大的页表的检查次数。(e.g. 对 pagedir_get_page()的调用)。如果系统调用只 copy 了 2 bytes 的数据呢？还有没有空间优化？可以优化多少？\n  B5: Briefly describe your implementation of the \u0026ldquo;wait\u0026rdquo; system call and how it interacts with process termination.\nB5: 简要描述你\u0026quot;wait\u0026quot;系统调用的实现以及它是如何与进程停止交互的。\n  B6: Any access to user program memory at a user-specified address can fail due to a bad pointer value. Such accesses must cause the process to be terminated. System calls are fraught with such accesses, e.g. a \u0026ldquo;write\u0026rdquo; system call requires reading the system call number from the user stack, then each of the call\u0026rsquo;s three arguments, then an arbitrary amount of user memory, and any of these can fail at any point. This poses a design and error-handling problem: how do you best avoid obscuring the primary function of code in a morass of error-handling? Furthermore, when an error is detected, how do you ensure that all temporarily allocated resources (locks, buffers, etc.) are freed? In a few paragraphs, describe the strategy or strategies you adopted for managing these issues. Give an example.\n任何在用户指定的地址上对用户程序的内存的访问可能因为指针错误而失败。此类访问一定导致进程终止。系统调用充满了这样的访问。如一个“写”系统调用需要先从用户栈中读系统调用号，然后每一个调用的 3 个参数，然后是任意数量的用户内存。任何这些都可能造成失败。这构成一个设计错误处理的问题：如何最好地避免混淆主要错误处理的烦恼？此外，当错误被检查到，你如何保证所有的临时开出的资源（锁、缓冲区等）都被释放？用几段话来描述你处理这些问题的策略。\n SYNCHRONIZATION #   B7: The \u0026ldquo;exec\u0026rdquo; system call returns -1 if loading the new executable fails, so it cannot return before the new executable has completed loading. How does your code ensure this? How is the load success/failure status passed back to the thread that calls \u0026ldquo;exec\u0026rdquo;?\nB7: 如果新的可执行文件加载失败，\u0026ldquo;exec\u0026quot;系统调用会返回-1，所以它不能够在该新的可执行文件成功加载之前返回。你的代码是如何保证这一点的？加载成功/失败的状态是如何传递回调用\u0026quot;exec\u0026quot;的线程的？\n  B8: Consider parent process P with child process C. How do you ensure proper synchronization and avoid race conditions when P calls wait(C) before C exits? After C exits? How do you ensure that all resources are freed in each case? How about when P terminates without waiting, before C exits? After C exits? Are there any special cases?\nB8: 考虑有父进程 P 和它的子进程 C。当 P 在 C exit 之前调用 wait(C)时，你如何确保同步以及如何避免争用的情况？你如何确保在每种情况下，所有的资源都被释放？如果 P 在 C exit 之前，没有 waiting 便终止？如果在 C exit 之后？有什么特殊情况吗？\n RATIONALE #   B9: Why did you choose to implement access to user memory from the kernel in the way that you did?\nB9: 为什么你使用这种方式来实现从内核对用户内存的访问？\n  B10: What advantages or disadvantages can you see to your design for file descriptors?\nB10: 你对文件描述符的设计有什么优劣吗？\n  B11: The default tid_t to pid_t mapping is the identity mapping. If you changed it, what advantages are there to your approach?\nB11: 默认的 tid_t 到 pid_t 的映射是 identity mapping。如果你进行了更改，那么你的方法有什么优点？\n 空白模板 #  # Project 2 Design Document ## QUESTION 1: ARGUMENT PASSING  ### DATA STRUCTURES \u0026gt; A1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less.  ### ALGORITHMS \u0026gt; A2: Briefly describe how you implemented argument parsing. How do you arrange for the elements of argv[] to be in the right order? How do you avoid overflowing the stack page? \u0026gt; \u0026gt; A2: 简要描述你是怎么实现 Argument parsing 的。你是如何安排 argv[]中的 elements，使其在正确的顺序的？你是如何避免 stack page 的溢出的？  ### RATIONALE \u0026gt; A3: Why does Pintos implement strtok_r() but not strtok()? \u0026gt; \u0026gt; A3: 为什么 Pintos 中实现 strtok_r()而不是 strtok()？ \u0026gt; A4: In Pintos, the kernel separates commands into a executable name and arguments. In Unix-like systems, the shell does this separation. Identify at least two advantages of the Unix approach. \u0026gt; \u0026gt; A4: 在 Pintos 中，kernel 将命令分成了可执行文件的 name 以及参数。在 Unix-like 的系统中，shell 完成这部分的分隔。列举至少 2 种 Unix 这样做的好处。  ## QUESTION 2: SYSTEM CALLS  ### DATA STRUCTURES \u0026gt; B1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less. \u0026gt; B2: Describe how file descriptors are associated with open files. Are file descriptors unique within the entire OS or just within a single process? \u0026gt; \u0026gt; B2: 描述文件描述符是如何与打开文件相联系的。文件描述符是在整个中唯一还是仅在单个进程中唯一？  ### ALGORITHMS \u0026gt; B3: Describe your code for reading and writing user data from the kernel. \u0026gt; \u0026gt; B3: 描述你用来从 kernel 中读写文件的代码。 \u0026gt; B4: Suppose a system call causes a full page (4,096 bytes) of data to be copied from user space into the kernel. What is the least and the greatest possible number of inspections of the page table (e.g. calls to pagedir_get_page()) that might result? What about for a system call that only copies 2 bytes of data? Is there room for improvement in these numbers, and how much? \u0026gt; \u0026gt; B4: 假设一个系统调用造成一整页的数据(4096 bytes)从用户空间复制到 kernel。 \u0026gt; \u0026gt; 求可能造成的最小和最大的页表的检查次数。(e.g. 对 pagedir_get_page()的调用)。如果系统调用只 copy 了 2 bytes 的数据呢？还有没有空间优化？可以优化多少？ \u0026gt; B5: Briefly describe your implementation of the \u0026#34;wait\u0026#34; system call and how it interacts with process termination. \u0026gt; \u0026gt; B5: 简要描述你\u0026#34;wait\u0026#34;系统调用的实现以及它是如何与进程停止交互的。 \u0026gt; B6: Any access to user program memory at a user-specified address can fail due to a bad pointer value. Such accesses must cause the process to be terminated. System calls are fraught with such accesses, e.g. a \u0026#34;write\u0026#34; system call requires reading the system call number from the user stack, then each of the call\u0026#39;s three arguments, then an arbitrary amount of user memory, and any of these can fail at any point. This poses a design and error-handling problem: how do you best avoid obscuring the primary function of code in a morass of error-handling? Furthermore, when an error is detected, how do you ensure that all temporarily allocated resources (locks, buffers, etc.) are freed? In a few paragraphs, describe the strategy or strategies you adopted for managing these issues. Give an example. \u0026gt; \u0026gt; 任何在用户指定的地址上对用户程序的内存的访问可能因为指针错误而失败。此类访问一定导致进程终止。系统调用充满了这样的访问。如一个“写”系统调用需要先从用户栈中读系统调用号，然后每一个调用的 3 个参数，然后是任意数量的用户内存。任何这些都可能造成失败。这构成一个设计错误处理的问题：如何最好地避免混淆主要错误处理的烦恼？此外，当错误被检查到，你如何保证所有的临时开出的资源（锁、缓冲区等）都被释放？用几段话来描述你处理这些问题的策略。  ### SYNCHRONIZATION \u0026gt; B7: The \u0026#34;exec\u0026#34; system call returns -1 if loading the new executable fails, so it cannot return before the new executable has completed loading. How does your code ensure this? How is the load success/failure status passed back to the thread that calls \u0026#34;exec\u0026#34;? \u0026gt; \u0026gt; B7: 如果新的可执行文件加载失败，\u0026#34;exec\u0026#34;系统调用会返回-1，所以它不能够在该新的可执行文件成功加载之前返回。你的代码是如何保证这一点的？加载成功/失败的状态是如何传递回调用\u0026#34;exec\u0026#34;的线程的？ \u0026gt; B8: Consider parent process P with child process C. How do you ensure proper synchronization and avoid race conditions when P calls wait(C) before C exits? After C exits? How do you ensure that all resources are freed in each case? How about when P terminates without waiting, before C exits? After C exits? Are there any special cases? \u0026gt; \u0026gt; B8: 考虑有父进程 P 和它的子进程 C。当 P 在 C exit 之前调用 wait(C)时，你如何确保同步以及如何避免争用的情况？你如何确保在每种情况下，所有的资源都被释放？如果 P 在 C exit 之前，没有 waiting 便终止？如果在 C exit 之后？有什么特殊情况吗？  ### RATIONALE \u0026gt; B9: Why did you choose to implement access to user memory from the kernel in the way that you did? \u0026gt; \u0026gt; B9: 为什么你使用这种方式来实现从内核对用户内存的访问？ \u0026gt; B10: What advantages or disadvantages can you see to your design for file descriptors? \u0026gt; \u0026gt; B10: 你对文件描述符的设计有什么优劣吗？ \u0026gt; B11: The default tid_t to pid_t mapping is the identity mapping. If you changed it, what advantages are there to your approach? \u0026gt; \u0026gt; B11: 默认的 tid_t 到 pid_t 的映射是 identity mapping。如果你进行了更改，那么你的方法有什么优点？ "},{"id":8,"href":"/os-labs/docs/table-of-contents/","title":"Table of Contents","section":"Docs","content":"你好，操作系统！ #  Hello, Pintos!\n目录 #  实验目录可见左侧边栏\n"},{"id":9,"href":"/os-labs/docs/resources/","title":"Resources","section":"Docs","content":"课程相关资源 #  此处存放了周例会的模板及每次实验需要提交的文档模板。\n"}]