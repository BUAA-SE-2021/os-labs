[{"id":0,"href":"/os-labs/docs/table-of-contents/ps0/","title":"Problem Set 0","section":"Table of Contents","content":"Problem Set 0 #  实验说明 #   单人完成，代码要求每人一份（只需提交两个 *.c文件）。除代码外，还需要提交文档。内容可为设计和需求说明、解决思路等，无文档模板，自由发挥。 对于每个人而言，请仅提交一个 PDF 文件（如果有多个文档，请合并成一个。推荐把所有内容写在一个 Markdown/LaTex 项目里）。由组长将每个人的代码文件和 PDF 文档收齐后，将每个人的提交内容放在各自的文件夹后打包为 Zip 包提交。 本次实验因为不涉及多人合作，故对 Git 的使用没有要求。此后的 Project 1 开始，会对小组使用 Git 的情况进行考察。 本实验需要利用操作系统的同步机制，实现问题中要求的逻辑功能。 实验代码可在官网中自行下载，无需 Pintos 环境即可直接运行。  实验内容 #   Problem 1：自动化车站  乘客行为：到站台等车、车来则上车 火车行为：到站装载乘客，无人等待或车已满就开走 让乘客和火车的行为流畅运行，以实现车站的自动化管理   Problem 2：氢原子与氧原子结合，生成 H2O  2 个 H 和 1 个 O 生成水分子 如何保证 H2O 结构正常生成，不会遗漏或多加原子    Problem 1 #  需求 #  CalTrain 程序想让你通过自动化列车和乘客管理来提高效率。每名乘客和每列火车都由一个线程控制。 要求编写同步函数，以确保列车的有序装载。避免出现多人上车座位不够的情况。\n步骤 #   定义 station 结构体  包含程序所用的信号量、锁、条件变量   编写以下处理函数：  初始化函数：station_init(struct station *station) 初始化结构体中的数据   列车行为：  火车到站打开车门：station_load_train(struct station *station, int count) 当且仅当列车已满或无乘客等待时，该函数返回   乘客行为：  到站等车，添加一名位于等待状态的乘客：station_wait_for_train(struct station *station) 乘客就坐，“通知”列车当前乘客已经就坐：station_on_board(struct station *station)   外层调用无需考虑，只需定义结构体和同步机制所需的函数  要求 #   允许多名乘客等车 只需改动 caltrain.c 不能造成忙等待 只能使用以下函数  lock_init (struct lock *lock) lock_acquire(struct lock *lock) lock_release(struct lock *lock) cond_init(struct condition *cond) cond_wait(struct condition *cond, struct lock *lock) cond_signal(struct condition *cond, struct lock *lock) cond_broadcast(struct condition *cond, struct lock *lock)    Problem 2 #  需求 #  大自然母亲聘请你帮助她解决形成水的化学反应，但是她似乎无法正确处理反应中的同步问题。 将两个 H 原子和一个 O 原子同时放在一起即可生成水分子， 每个原子由一个线程表示。\n步骤 #   定义 reaction 结构体 包含程序所用的信号量、锁、条件变量 编写以下处理函数：  初始化函数：reaction_init(struct reaction *r) 氢氧原子准备结合：void reaction_h(struct reaction *r)、void reaction_o(struct reaction *r) 每有一个 H 或 O 原子进入等待，调用该函数，结合成功后返回   在代码中包含结合水的函数：make_water()  无需实现，已经给出，需要在逻辑中加入    要求 #   允许多个原子等待反应 不能造成忙等待 只需改动 reation.c 只能使用以下函数  lock_init (struct lock *lock) lock_acquire(struct lock *lock) lock_release(struct lock *lock) cond_init(struct condition *cond) cond_wait(struct condition *cond, struct lock *lock) cond_signal(struct condition *cond, struct lock *lock) cond_broadcast(struct condition *cond, struct lock *lock)    测试方法 #   在代码根目录下命令行运行 make run 重新编译记得 make clean  正常运行时命令行输出：\n...Train departed station with 17 new passenger(s) (expected 17) Looks good! ./reaction 0 Created 0 H and 200 O atoms (0.0% H), expecting 0 H2O molecules Looks good! "},{"id":1,"href":"/os-labs/docs/resources/weekly-meeting-report/","title":"周例会报告模板","section":"Resources","content":"周例会报告 #  会议基本信息 #   会议日期： 时间： 参会人员： 地点： 记录人： 会议主题：  规划议程 #  会议内容 #   简述会议实际进程，突出谁发现了什么问题，谁解决了什么问题，并是怎么解决的\n 下一阶段目标和打算 #  参会人员小结 #  空白模板 #  # 周例会报告 ## 会议基本信息  - 会议日期： - 时间： - 参会人员： - 地点： - 记录人： - 会议主题： ## 规划议程  ## 会议内容 \u0026gt; 简述会议实际进程，突出谁发现了什么问题，谁解决了什么问题，并是怎么解决的  ## 下一阶段目标和打算  ## 参会人员小结 参考的填写模板 #  # 周例会报告 ## 会议基本信息  - 会议日期：20210930 - 时间：15:00-18:00 - 参会人员：zzj、hhz、wyh、lrq - 地点：腾讯会议、新主楼 - 记录人：zyh - 会议主题：开始实验前任务布置 ## 规划议程  - 15:00-16:00 一起读题 - 16:00-17:00 讨论解决思路 - 17:00-18:00 看代码，debug ## 会议内容  zzj 带领我们看了一下代码的结构，根据助教的提示明确了实验内容要做什么。 wyh 发现在 `xx.h` 里，需要定义一个新的结构体，因为 `xxx.c` 里要用，我们要通过它来实现同步。 lrq 认为`void` 的使用还难，我们一起查了下网上博客，发现他的用法有 xxx。 会议的最后，hhz 给 zzj、wyh、lrq 倒了杯卡布奇诺，说“兄弟们，辛苦了”。 ## 下一阶段目标和打算  提前做完实验，下一周讨论一下 Project 2 怎么搞。 ## 各参会人员小结  ### zzj  今天我带领了组内成员读了题目，解决了重要 BUG，顺利 AK。 ### hhz  ... "},{"id":2,"href":"/os-labs/docs/resources/install-pintos/","title":"Pintos 环境搭建","section":"Resources","content":"Pintos 环境搭建 #   Author: Muyung, YinghaoZhu\n 依赖安装 #  我所使用的实验环境为 VMware Workstation 16 Player (免费) 上运行的 Ubuntu 16.04 64 位版本（32 位版本不可以）。\n  Download VMware Workstation 16 Player  Download Ubuntu 16.04  选择 ubuntu-16.04.7-desktop-amd64.iso    安装 GNU binutils #  安装成功后，终端运行 i386-elf-objdump -i，应输出：\nBFD header file version (GNU Binutils) 2.21.1 elf32-i386 (header little endian, data little endian) i386... 如果未出现这一信息，则需要安装 binutils ：\n首先下载该依赖包：终端执行 wget http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2\n解压并安装：\ntar xjf binutils-2.21.1.tar.bz2 cd binutils-2.21.1 ./configure --prefix=/usr/local --target=i386-elf --disable-werror make sudo make install # 这一步权限必不可少 cd .. 安装 Bochs #  这里采用的 Bochs 版本是 2.6.7，而非 Pintos 推荐的 2.2.6，因为过旧版本的 bochs 已经无法通过新版本 gcc 的编译。\n这里先将可能用到的依赖都安装验证一遍：\nsudo apt-get update # 更新 apt 库 sudo apt-get -y install build-essential # -y 参数自动确认 (Y/n) sudo apt-get -y install xorg-dev sudo apt-get -y install bison sudo apt-get -y install libgtk2.0-dev sudo apt-get -y install libc6:i386 libgcc1:i386 libstdc++5:i386 libstdc++6:i386 sudo apt-get -y install libncurses5:i386 sudo apt-get -y install g++-multilib  下载 bochs02.6.7 链接\n点击\u0026quot;bochs-2.6.7.tar.gz\u0026quot;下载，解压并安装（其与 Pintos 都已上传至 BUAA-SE-2021 pintos 仓库的 materials 文件夹下，可一起压缩后拖到虚拟机里去再解压，直接拖文件夹会比较慢）：\ntar xzf bochs-2.6.7.tar.gz cd bochs-2.6.7 chmod +x ./configure # 赋可执行权限 ./configure --enable-gdb-stub make sudo make install # 这一步权限必不可少 Pintos 安装 #  解压该 Ubuntu 16 所对应版本的 Pintos\ntar xzf pintos.tar.gz 复制脚本 #  这一步需要把 pintos/src/utils 文件夹下的诸多脚本文件添加到环境变量 PATH 下，这里直接将它们复制至 /usr/bin 文件夹下。\ncd ~/pintos/src/utils # 进入 Pintos 所在的文件夹，此处为家目录 sudo cp backtrace /usr/bin sudo cp pintos /usr/bin sudo cp pintos-gdb /usr/bin sudo cp pintos-mkdisk /usr/bin sudo cp pintos-set-cmdline /usr/bin sudo cp Pintos.pm /usr/bin cd ../misc sudo cp gdb-macros /usr/bin 安装 pintos-gdb #  首先编辑 /usr/bin/pintos-gdb 文件，将其中的常量 GDBMACROS 改为放置 gdb-macros 副本的路径（即：/usr/bin/gdb-macros）\nsudo vi /usr/bin/pintos-gdb # Modify the 4th line: GDBMACROS=/usr/bin/gdb-macros 然后设置脚本的执行权限\ncd /usr/bin/ sudo chmod a+rx backtrace sudo chmod a+rx pintos* sudo chmod a+rx gdb-macros sudo chmod a+rx Pintos.pm test pintos-gdb # 如果未提示缺少 gdb-macros 则安装成功 编译 utils #  修改 Makefile 文件，将第 5 行的 LDFLAGS 修改为 LDLIBS\ncd ~/pintos/src/utils vi Makefile # Modify the 5th line: LDFLAGS -\u0026gt; LDLIBS make 命令编译，并将支持文件导入 /usr/bin\nmake sudo cp squish-pty /usr/bin sudo cp squish-unix /usr/bin sudo chmod a+rx /usr/bin/squish* 安装并运行 #  执行如下命令：\ncd ~/pintos/src/threads make cd build chmod +x ../../utils/pintos # 可能需要赋可执行权限 ../../utils/pintos -- run alarm-multiple 即可看到 Pintos 的运行界面，含以下输出：\nUse of literal control characters in variable names is deprecated at ../../utils/pintos line 911. Prototype mismatch: sub main::SIGVTALRM () vs none at ../../utils/pintos line 935. Constant subroutine SIGVTALRM redefined at ../../utils/pintos line 927. squish-pty bochs -q ======================================================================== Bochs x86 Emulator 2.6.7 Built from SVN snapshot on November 2, 2014 Compiled on Sep 28 2021 at 01:44:48 ======================================================================== 00000000000i[ ] reading configuration from bochsrc.txt 00000000000e[ ] bochsrc.txt:8: \u0026#39;user_shortcut\u0026#39; will be replaced by new \u0026#39;keyboard\u0026#39; option. 00000000000i[ ] installing x module as the Bochs GUI 00000000000i[ ] using log file bochsout.txt PiLo hda1 Loading........... Kernel command line: run alarm-multiple Pintos booting with 4,096 kB RAM... 383 pages available in kernel pool. 383 pages available in user pool. Calibrating timer... 204,600 loops/s. Boot complete. Executing \u0026#39;alarm-multiple\u0026#39;: (alarm-multiple) begin (alarm-multiple) Creating 5 threads to sleep 7 times each. (alarm-multiple) Thread 0 sleeps 10 ticks each time, (alarm-multiple) thread 1 sleeps 20 ticks each time, and so on. (alarm-multiple) If successful, product of iteration count and (alarm-multiple) sleep duration will appear in nondescending order. (alarm-multiple) thread 0: duration=10, iteration=1, product=10 (alarm-multiple) thread 0: duration=10, iteration=2, product=20 (alarm-multiple) thread 1: duration=20, iteration=1, product=20 (alarm-multiple) thread 2: duration=30, iteration=1, product=30 (alarm-multiple) thread 0: duration=10, iteration=3, product=30 (alarm-multiple) thread 0: duration=10, iteration=4, product=40 (alarm-multiple) thread 1: duration=20, iteration=2, product=40 (alarm-multiple) thread 3: duration=40, iteration=1, product=40 (alarm-multiple) thread 4: duration=50, iteration=1, product=50 (alarm-multiple) thread 0: duration=10, iteration=5, product=50 (alarm-multiple) thread 1: duration=20, iteration=3, product=60 (alarm-multiple) thread 2: duration=30, iteration=2, product=60 (alarm-multiple) thread 0: duration=10, iteration=6, product=60 (alarm-multiple) thread 0: duration=10, iteration=7, product=70 (alarm-multiple) thread 1: duration=20, iteration=4, product=80 (alarm-multiple) thread 3: duration=40, iteration=2, product=80 (alarm-multiple) thread 2: duration=30, iteration=3, product=90 (alarm-multiple) thread 4: duration=50, iteration=2, product=100 (alarm-multiple) thread 1: duration=20, iteration=5, product=100 (alarm-multiple) thread 1: duration=20, iteration=6, product=120 (alarm-multiple) thread 2: duration=30, iteration=4, product=120 (alarm-multiple) thread 3: duration=40, iteration=3, product=120 (alarm-multiple) thread 1: duration=20, iteration=7, product=140 (alarm-multiple) thread 4: duration=50, iteration=3, product=150 (alarm-multiple) thread 2: duration=30, iteration=5, product=150 (alarm-multiple) thread 3: duration=40, iteration=4, product=160 (alarm-multiple) thread 2: duration=30, iteration=6, product=180 (alarm-multiple) thread 3: duration=40, iteration=5, product=200 (alarm-multiple) thread 4: duration=50, iteration=4, product=200 (alarm-multiple) thread 2: duration=30, iteration=7, product=210 (alarm-multiple) thread 3: duration=40, iteration=6, product=240 (alarm-multiple) thread 4: duration=50, iteration=5, product=250 (alarm-multiple) thread 3: duration=40, iteration=7, product=280 (alarm-multiple) thread 4: duration=50, iteration=6, product=300 (alarm-multiple) thread 4: duration=50, iteration=7, product=350 (alarm-multiple) end Execution of \u0026#39;alarm-multiple\u0026#39; complete. "},{"id":3,"href":"/os-labs/docs/resources/doc-template/","title":"实验文档模板","section":"Resources","content":"Project X 实验文档模板 #   Project X (X = 1, 2, 3)\n 团队 #  基本信息 #     姓名 学号                      每位组员的主要工作内容 #  Git 相关 #   Pintos 的 Git 项目地址\n参考资料 #    资料 1  资料 2  实验要求 #  需求分析 #  设计思路 #   可描述算法描述、数据结构等\n 重难点讲解 #   可写踩坑记录、Debug 的解决方案等\n 用户手册 #  测试报告 #  各成员的心得体会 #  Student1 #  Student2 #  \u0026hellip;\n其他你认为有必要的内容 (Optional) #  空白 Markdown 模板 #  # Project X 实验文档 ## 团队  ### 基本信息  | 姓名 | 学号 | | ---- | ---- | | | | | | | | | | | | | ### 每位组员的主要工作内容  ### Git 相关  [Pintos 的 Git 项目地址]() ### 参考资料  1. []() 2. []() ## 实验要求  ## 需求分析  ## 设计思路  ## 重难点讲解  ## 用户手册  ## 测试报告  ## 各成员的心得体会  ### Student1  ### Student2  ### Student3  ### Student4  ## 其他你认为有必要的内容 (Optional) "},{"id":4,"href":"/os-labs/docs/resources/project01-design-doc/","title":"Project 1 DesignDoc 模板","section":"Resources","content":"Project 1 Design Document #  QUESTION 1: ALARM CLOCK #  DATA STRUCTURES #   A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n ALGORITHMS #   A2: Briefly describe what happens in a call to timer_sleep(), including the effects of the timer interrupt handler.\n  A3: What steps are taken to minimize the amount of time spent in the timer interrupt handler?\n SYNCHRONIZATION #   A4: How are race conditions avoided when multiple threads call timer_sleep() simultaneously?\n  A5: How are race conditions avoided when a timer interrupt occurs during a call to timer_sleep()?\n RATIONALE #   A6: Why did you choose this design? In what ways is it superior to another design you considered?\n QUESTION 2: PRIORITY SCHEDULING #  DATA STRUCTURES #   B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n  B2: Explain the data structure used to track priority donation. Use ASCII art to diagram a nested donation. (Alternately, paste an image.)\n ALGORITHMS #   B3: How do you ensure that the highest priority thread waiting for a lock, semaphore, or condition variable wakes up first?\n  B4: Describe the sequence of events when a call to lock_acquire() causes a priority donation. How is nested donation handled?\n  B5: Describe the sequence of events when lock_release() is called on a lock that a higher-priority thread is waiting for.\n SYNCHRONIZATION #   B6: Describe a potential race in thread_set_priority() and explain how your implementation avoids it. Can you use a lock to avoid this race?\n RATIONALE #   B7: Why did you choose this design? In what ways is it superior to another design you considered?\n QUESTION 3: ADVANCED SCHEDULER #  DATA STRUCTURES #   C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration. Identify the purpose of each in 25 words or less.\n ALGORITHMS #   C2: Suppose threads A, B, and C have nice values 0, 1, and 2. Each has a recent_cpu value of 0. Fill in the table below showing the scheduling decision and the priority and recent_cpu values for each thread after each given number of timer ticks:\n    timer ticks recent_cpu A recent_cpu B recent_cpu C priority A priority B priority C thread to run     0          4          8          12          16          20          24          24          32          36            C3: Did any ambiguities in the scheduler specification make values in the table uncertain? If so, what rule did you use to resolve them? Does this match the behavior of your scheduler?\n  C4: How is the way you divided the cost of scheduling between code inside and outside interrupt context likely to affect performance?\n RATIONALE #   C5: Briefly critique your design, pointing out advantages and disadvantages in your design choices. If you were to have extra time to work on this part of the project, how might you choose to refine or improve your design?\n 空白模板 #  # Project 1 Design Document ## QUESTION 1: ALARM CLOCK  ### DATA STRUCTURES \u0026gt; A1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less.  ### ALGORITHMS \u0026gt; A2: Briefly describe what happens in a call to timer_sleep(), including the effects of the timer interrupt handler. \u0026gt; A3: What steps are taken to minimize the amount of time spent in the timer interrupt handler?  ### SYNCHRONIZATION \u0026gt; A4: How are race conditions avoided when multiple threads call timer_sleep() simultaneously? \u0026gt; A5: How are race conditions avoided when a timer interrupt occurs during a call to timer_sleep()?  ### RATIONALE \u0026gt; A6: Why did you choose this design? In what ways is it superior to another design you considered?  ## QUESTION 2: PRIORITY SCHEDULING  ### DATA STRUCTURES \u0026gt; B1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less. \u0026gt; B2: Explain the data structure used to track priority donation. Use ASCII art to diagram a nested donation. (Alternately, paste an image.)  ### ALGORITHMS \u0026gt; B3: How do you ensure that the highest priority thread waiting for a lock, semaphore, or condition variable wakes up first? \u0026gt; B4: Describe the sequence of events when a call to lock_acquire() causes a priority donation. How is nested donation handled? \u0026gt; B5: Describe the sequence of events when lock_release() is called on a lock that a higher-priority thread is waiting for.  ### SYNCHRONIZATION \u0026gt; B6: Describe a potential race in thread_set_priority() and explain how your implementation avoids it. Can you use a lock to avoid this race?  ### RATIONALE \u0026gt; B7: Why did you choose this design? In what ways is it superior to another design you considered?  ## QUESTION 3: ADVANCED SCHEDULER  ### DATA STRUCTURES \u0026gt; C1: Copy here the declaration of each new or changed `struct` or `struct` member, global or static variable, `typedef`, or enumeration. Identify the purpose of each in 25 words or less.  ### ALGORITHMS \u0026gt; C2: Suppose threads A, B, and C have nice values 0, 1, and 2. Each has a recent_cpu value of 0. Fill in the table below showing the scheduling decision and the priority and recent_cpu values for each thread after each given number of timer ticks:  | timer ticks | `recent_cpu` A | `recent_cpu` B | `recent_cpu` C | `priority` A | `priority` B | `priority` C | thread to run | | ----------- | -------------- | -------------- | -------------- | ------------ | ------------ | ------------ | ------------- | | 0 | | | | | | | | | 4 | | | | | | | | | 8 | | | | | | | | | 12 | | | | | | | | | 16 | | | | | | | | | 20 | | | | | | | | | 24 | | | | | | | | | 24 | | | | | | | | | 32 | | | | | | | | | 36 | | | | | | | | \u0026gt; C3: Did any ambiguities in the scheduler specification make values in the table uncertain? If so, what rule did you use to resolve them? Does this match the behavior of your scheduler? \u0026gt; C4: How is the way you divided the cost of scheduling between code inside and outside interrupt context likely to affect performance?  ### RATIONALE \u0026gt; C5: Briefly critique your design, pointing out advantages and disadvantages in your design choices. If you were to have extra time to work on this part of the project, how might you choose to refine or improve your design? "},{"id":5,"href":"/os-labs/docs/table-of-contents/","title":"Table of Contents","section":"Docs","content":"你好，操作系统！ #  Hello, Pintos!\n目录 #  实验目录可见左侧边栏\n"},{"id":6,"href":"/os-labs/docs/resources/","title":"Resources","section":"Docs","content":"课程相关资源 #  此处存放了周例会的模板及每次实验需要提交的文档模板。\n"}]